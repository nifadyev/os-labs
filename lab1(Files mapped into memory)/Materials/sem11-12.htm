<html><head>

<meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><title>Семинары 11-12</title></head><body bgcolor="#ffffff">
  <basefont face="Times New Roman, sans-serif, Courier, mono" size="3">
  
<p align="center"><b><font face="Times New Roman" size="6">Семинары 11-12. Организация 
  файловой системы в UNIX. Работа с файлами и директориями. Понятие о memory mapped 
  файлах.</font></b></p>
<p align="center">(Основываются на <a href="http://cs.mipt.ru/docs/courses/osstud/11/l11.htm">лекции 11</a> и 
  <a href="http://cs.mipt.ru/docs/courses/osstud/12/l12.htm">лекции 12</a>) </p>
<p align="center"><a href="http://cs.mipt.ru/docs/courses/osstud/exams/kr1h.htm"> Предыдущий семинар</a> | <a href="http://cs.mipt.ru/docs/courses/osstud/os.html">Программа курса</a> | 
 <a href="http://cs.mipt.ru/docs/courses/osstud/13/prep/sem13-14.htm"> Следующий семинар</a></p>

<font face="Times New Roman" size="4">  <b><p align="center">Программа семинара</p> </b></font>
<ol>
<li><a href="#s1101"> 
    </a><p align="justify"><a href="#s1101"><font face="Times New Roman, Times, serif" size="3"> Введение. </font> 
    </a>
  </p></li><li><a href="#s1102"> 
    </a><p align="justify"><a href="#s1102"><font face="Times New Roman, Times, serif" size="3"> Разделы 
      носителя информации (partitions) в UNIX. </font> 
    </a>
  </p></li><li><a href="#s1103"> 
    </a><p align="justify"><a href="#s1103"><font face="Times New Roman, Times, serif" size="3">Логическая 
      структура файловой системы и типы файлов в UNIX. </font> 
    </a>
  </p></li><li><a href="#s1104"> 
    </a><p align="justify"><a href="#s1104"><font face="Times New Roman, Times, serif" size="3">Организация 
      файла на диске в UNIX на примере файловой системы s5fs. Понятие индексного 
      узла (inode). </font> 
    </a>
  </p></li><li><a href="#s1105"> 
    </a><p align="justify"><a href="#s1105"><font face="Times New Roman, Times, serif" size="3">Организация 
      директорий (каталогов) в UNIX. </font> 
    </a>
  </p></li><li><a href="#s1106"> 
    </a><p align="justify"><a href="#s1106"><font face="Times New Roman, Times, serif" size="3">Понятие 
      суперблока. </font>
    </a>
  </p></li><li><a href="#s1107"> 
    </a><p align="justify"><a href="#s1107"><font face="Times New Roman, Times, serif" size="3"> Операции 
      над файлами и директориями.</font> 
    </a>
  
  </p></li><li><a href="#s1108"> 
    <p align="justify"><font face="Times New Roman, Times, serif" size="3"> Системные 
      вызовы и команды для выполнения операций над файлами и директориями.</font></p> 
    </a>
	<ul type="square">
	<a href="#s110801"> </a><li><a href="#s110801">    </a><p align="justify"><a href="#s110801"><font face="Times New Roman, Times, serif" size="3"> 
	Системный вызов open().
	</font></a>
	<a href="#s110802"> </a></p></li><li><a href="#s110802">    </a><p align="justify"><a href="#s110802"><font face="Times New Roman, Times, serif" size="3"> 
	Системный вызов close().
	</font></a>
	<a href="#s110803"> </a></p></li><li><a href="#s110803">    </a><p align="justify"><a href="#s110803"><font face="Times New Roman, Times, serif" size="3"> 
	Операция создания файла. Системный вызов creat().
	</font></a>
	<a href="#s110804"> </a></p></li><li><a href="#s110804">    
        </a><p align="justify"><a href="#s110804"><font face="Times New Roman, Times, serif" size="3"> 
          Операция чтения атрибутов файла. Системные вызовы stat(), fstat() и 
          lstat(). </font>
      </a>
	<a href="#s110805"> </a></p></li><li><a href="#s110805">    </a><p align="justify"><a href="#s110805"><font face="Times New Roman, Times, serif" size="3"> 
	Операции изменения атрибутов файла.
	</font></a>
	<a href="#s110806"> </a></p></li><li><a href="#s110806">    </a><p align="justify"><a href="#s110806"><font face="Times New Roman, Times, serif" size="3"> 
	Операции чтения из файла и записи в файл.
	</font></a>
	<a href="#s110807"> </a></p></li><li><a href="#s110807">    </a><p align="justify"><a href="#s110807"><font face="Times New Roman, Times, serif" size="3"> 
	Операция изменения указателя текущей позиции. Системный 
      вызов lseek().
	</font></a>
	<a href="#s110808"> </a></p></li><li><a href="#s110808">    </a><p align="justify"><a href="#s110808"><font face="Times New Roman, Times, serif" size="3"> 
	Операция добавления информации в файл. Флаг O_APPEND.
	</font></a>
	<a href="#s110809"> </a></p></li><li><a href="#s110809">    </a><p align="justify"><a href="#s110809"><font face="Times New Roman, Times, serif" size="3"> 
	Операции создания связей. Команда ln, системные 
      вызовы link() и symlink().
	</font></a>
	<a href="#s110810"> </a></p></li><li><a href="#s110810">    </a><p align="justify"><a href="#s110810"><font face="Times New Roman, Times, serif" size="3"> 
	Операция удаления связей и файлов. Системный вызов unlink().
	</font></a>

	</p></li></ul><br>
	</li>
	<li><a href="#s1110"> 
    </a><p align="justify"><a href="#s1110"><font face="Times New Roman, Times, serif" size="3">  Специальные функции для работы с содержимым директорий. 
	</font> 
    </a>
  </p></li><li><a href="#s1112"> 
    </a><p align="justify"><a href="#s1112"><font face="Times New Roman, Times, serif" size="3"> Понятие 
      о файлах, отображаемых в память (memory mapped файлах). Системные вызовы 
      mmap(), munmap(). </font> 
    </a>
  
  

</p></li></ol>
<p align="center">
<font face="Times New Roman, Times, serif" size="3"><b><font size="4">Цели занятия</font></b></font> 
</p><ol>
    <li>
    <p align="justify"><font face="Times New Roman" size="3">Дать понятие об организации файловой 
    системы в </font><font size="3">UNIX.</font>
  
    </p></li><li>
    <p align="justify"><font face="Times New Roman" size="3">Научить выполнять операции над 
	файлами и директориями с помощью команд операционной системы и системных вызовов.</font>
  
    </p></li><li>
    <p align="justify"><font face="Times New Roman" size="3"> Научить анализировать 
      содержимое директорий с помощью функций стандартной библиотеки языка С и 
      системного вызова stat(). </font> 
  
    </p></li><li>
    <p align="justify"><font face="Times New Roman" size="3">Дать понятие о memory 
      mapped файлах и работе с ними</font><font size="3">.</font> 
  
  
  </p></li></ol>
  <p align="center"><font face="Times New Roman, Times, serif" size="4"><b>Практические 
  работы</b></font></p>
  
<ol>
  <li>
    <p align="justify"><font face="Times New Roman, Times, serif" size="3"><a href="#s1109"> 
      Практическое применение команд и системных вызовов 
      для операций над файлами. </a></font> 
  
   </p></li><li>
    <p align="justify"><font face="Times New Roman, Times, serif" size="3"><a href="#s1111"> 
      Написание, прогон и компиляция программы, анализирующей содержимое директории. </a></font> 
  
   </p></li><li>
    <p align="justify"><font face="Times New Roman, Times, serif" size="3"><a href="#s1113"> 
       Анализ, компиляция и прогон программы для создания memory 
    mapped файла и записи его содержимого.</a></font> 
   </p></li><li>
    <p align="justify"><font face="Times New Roman, Times, serif" size="3"><a href="#s1114"> 
       Изменение предыдущей программы для чтения из файла, 
      используя его отображение в память.</a></font> 
  
  </p></li></ol>
  <p align="center"><b><font face="Times New Roman, Times, serif" size="4">План
занятия</font></b></p>
<ol>
  <li> 
    <p align="justify"> <font color="#ff0000" face="Times New Roman, Times, serif" size="3"><b> 
      <a name="s1101"></a>Введение.</b></font> <br>
      <br>
    </p><p align="justify"> <font face="Times New Roman, Times, serif" size="3"> <a href="http://cs.mipt.ru/docs/courses/osstud/11/ch11.htm#l1101"><img src="sem11-12_files/bookopen.gif" alt="Понятие файловой системы в лекции" align="right" border="0" height="34" hspace="10" vspace="1" width="48"></a> 
      На нескольких предыдущих семинарах (<a href="http://cs.mipt.ru/docs/courses/osstud/01/prep/sem1-2.htm">семинары 
      1-2</a>, <a href="http://cs.mipt.ru/docs/courses/osstud/05/prep/sem5.htm">семинар 5</a>) мы уже затрагивали 
      вопросы работы с файлами в UNIX. Но только теперь, после изучения на лекции 
      понятия файловой системы, мы можем рассмотреть файловую систему UNIX в целостности. 
      Наше рассмотрение, правда, ограничится достаточно общими вопросами, связанными 
      с организацией файловой системы, и системными вызовами, которые с наибольшей 
      вероятностью могут пригодиться в дальнейшем. Это связано как с ограниченностью 
      времени, которое отводится на работу с файловыми системами в нашем курсе, 
      так и с преимущественно практическим направлением наших занятий. <br>
      </font> <br>
  
  </p></li><li> 
    <p align="justify"> <font color="#ff0000" face="Times New Roman, Times, serif" size="3"><b> 
      <a name="s1102"></a> Разделы носителя информации (partitions) в UNIX.</b></font> 
      <br>
      <br>
    </p><p align="justify"> <font face="Times New Roman, Times, serif" size="3"> Физические 
      носители информации - магнитные или оптические диски, ленты и т.д., использующиеся 
      как физическая основа для хранения файлов, в операционных системах принято 
      логически делить на <i>разделы (partitions) </i>или <i>логические диски</i>. 
      <a href="http://cs.mipt.ru/docs/courses/osstud/12/ch12.htm#l1202"><img src="sem11-12_files/bookopen.gif" alt="Понятие  разделов в лекции" align="right" border="0" height="34" hspace="10" vspace="1" width="48"></a> 
      Причем слово "делить" не следует понимать буквально, в некоторых системах 
      несколько физических дисков могут быть объединены в один раздел. Об этом 
      подробнее вы узнаете на лекции. <br>
      <br>
      В операционной системе UNIX такое объединяющее разделение невозможно. В 
      UNIX физический носитель информации может представлять собой один раздел 
      или несколько разделов. В большинстве случаев разделение на разделы производится 
      линейно, хотя некоторые варианты UNIX могут допускать некое подобие древовидного 
      разбиения (Solaris). Количество разделов и их размеры определяются при форматировании 
      диска. Поскольку форматирование диска относится к области администрирования 
      операционных систем, оно не будет рассматриваться в нашем курсе.<br>
      <br>
      Наличие нескольких разделов на диске может определяться требованиями операционной 
      системы или пожеланиями пользователя. Допустим пользователь хочет разместить 
      на одном жестком диске несколько операционных систем с возможностью попеременной 
      работы в них, тогда он размещает каждую операционную систему в своем собственном 
      разделе. Другая ситуации, приводящая к желательности наличия нескольких 
      разделов внутри одной операционной системы, - это необходимость работы с 
      несколькими видами файловых систем. Под каждый тип файловой системы выделяется 
      отдельный логический диск. Третий вариант - это разбиение диска на разделы 
      для размещения в разных разделах различных категорий файлов. Скажем, в одном 
      разделе помещаются все системные файлы, а в другом разделе - все пользовательские 
      файлы. Примером операционной системы, внутренние требования которой приводят 
      к появлению нескольких разделов на диске, могут служить ранние версии MS-DOS, 
      для которых максимальный размер логического диска не мог превышать 32 MB. 
      <br>
      <br>
      Для простоты далее на этих семинарах будем полагать, что у нас имеется только 
      один раздел и, следовательно, одна файловая система. Вопросы взаимного сосуществования 
      нескольких файловых систем в рамках одной операционной системы мы затронем 
      <a href="http://cs.mipt.ru/docs/courses/osstud/13/prep/sem13-14.htm#s1302">на следующих семинарах</a> перед 
      обсуждением реализации подсистемы ввода-вывода.<br>
      </font> &nbsp;<br>
  
  </p></li><li> 
    <p align="justify"> <font color="#ff0000" face="Times New Roman, Times, serif" size="3"><b> 
      <a name="s1103"></a> Логическая структура файловой системы и типы файлов 
      в UNIX. </b></font> <br>
      <br>
    </p><p align="justify"> <font face="Times New Roman, Times, serif" size="3"> <a href="http://cs.mipt.ru/docs/courses/osstud/11/ch11.htm#l1101"><img src="sem11-12_files/bookopen.gif" alt="Понятие файла в лекции" align="right" border="0" height="34" hspace="10" vspace="1" width="48"></a>Мы 
      не будем давать здесь определение понятию файла, считая что интуитивное 
      представление о файлах у всех вас имеется, а на лекциях вы получили понятие 
      о файлах, как об именованных абстрактных объектах, обладающих определенными 
      свойствами. При этом в пространстве имен файлов одному файлу могут соответствовать 
      несколько имен. <br>
      <br>
      На <a href="http://cs.mipt.ru/docs/courses/osstud/01/prep/sem1-2.htm">семинарах 1-2</a> мы упрощенно говорили 
      о том, что файлы могут объединяться в директории, и что файлы и директории 
      организованы в древовидную структуру. На нынешнем уровне наших знаний мы 
      можем сформулировать это более аккуратно. В операционной системе UNIX существуют 
      файлы нескольких типов, а именно: <br>
      <br>
      </font> 
    </p><ul type="square">
      <li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          обычные или регулярные файлы; </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          директории или каталоги; </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          файлы типа FIFO или именованые pip'ы; </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          специальные файлы устройств; </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          сокеты (sockets);</font> 
      
      </p></li><li> 
        <p align="justify"><font face="Times New Roman, Times, serif" size="3"> 
          специальные файлы связи (link).<br>
          <br>
          </font> 
      
    </p></li></ul>
    <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> <a href="http://cs.mipt.ru/docs/courses/osstud/11/ch11.htm#l1104"><img src="sem11-12_files/bookopen.gif" alt="Типы и атрибуты файлов в лекции" align="right" border="0" height="34" hspace="10" vspace="1" width="48"></a> 
      Что такое регулярные файлы и директории вам должно быть хорошо известно 
      из личного опыта и из лекций. О способах их отображения в дисковое пространство 
      мы поговорим чуть позже. С файлами типа FIFO мы познакомились на <a href="http://cs.mipt.ru/docs/courses/osstud/05/prep/sem5.htm">семинаре 
      5</a>, когда говорили о работе с <a href="http://cs.mipt.ru/docs/courses/osstud/05/prep/sem5.htm#s0514">именоваными 
      pip'ами</a>. С файлами типа "связь" мы встретимся на этом семинаре, 
      когда будем обсуждать <a href="#s1107">операции над файлами</a> и <a href="#s110809">соответствующие 
      им системные вызовы</a>. Специальные файлы устройств будут рассмотрены нами 
      на <a href="http://cs.mipt.ru/docs/courses/osstud/13/prep/sem13-14.htm">семинарах 13-14</a>, посвященных 
      реализации в UNIX подсистемы ввода-вывода и передаче информации с помощью 
      сигналов. Файлы типа "сокет" будут введены нами на <a href="http://cs.mipt.ru/docs/courses/osstud/15/prep/sem15-16.htm">семинарах 
      15-16</a>, когда мы будем рассматривать вопросы сетевого программирования 
      в UNIX.<br>
      <br>
      Файлы всех этих типов логически объединены в ациклический граф с однонаправленными 
      ребрами, получающийся из дерева в результате сращивания вместе нескольких 
      терминальных узлов дерева или нескольких его нетерминальных узлов таким 
      образом, чтобы полученный граф не содержал циклов. В нетерминальных узлах 
      такого ациклического графа (т.е. в узлах, из которых выходят ребра) могут 
      располагаться только файлы типов "директория" и "связь". 
      Причем из узла, в котором располагается файл типа "связь" может 
      выходить только ровно одно ребро. В терминальных узлах этого ациклического 
      графа (т.е. в узлах, из которых не выходит ребер) могут располагаться файлы 
      любых типов, хотя присутствие в теминальном узле файла типа "связь" 
      обычно говорит о некотором нарушении целостности файловой системы. <br>
      <br>
      В отличие от древовидной структуры набора файлов, где имена файлов связывались 
      с узлами дерева, в таком ациклическом графе имя файла связывается не с узлом, 
      соответствующим файлу, а с входящим в него ребром. Ребра, выходящие из узлов, 
      соответствующих файлам типа "связь" являются неименоваными. Надо 
      отметить, что во всех практически существующих реализациях UNIX-подобных 
      систем в узел графа, соответствующий файлу типа "директория", 
      не может входить более одного именованого ребра, хотя стандарт на операционную 
      систему UNIX и не запрещает этого. Правила построения имен ребер (файлов) 
      рассматривались на <a href="http://cs.mipt.ru/docs/courses/osstud/01/prep/sem1-2.htm">семинарах 1-2</a>. 
      <a href="http://cs.mipt.ru/docs/courses/osstud/11/ch11.htm#l1107"><img src="sem11-12_files/bookopen.gif" alt="Полные имена файлов в лекции" align="right" border="0" height="34" hspace="10" vspace="1" width="48"></a> 
      В качестве полного имени файла может использоваться любое имя, получающееся 
      при прохождении по ребрам от корневого узла графа (т.е. узла, в который 
      не входит ни одно ребро) до узла, соотвествующего этому файлу, по любому 
      пути с помощью следующего алгоритма:</font><br>
      <br>
    </p><dir> 
      <ol>
        <li> 
          <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
            Если интересующему нас файлу соответствует корневой узел, то файл 
            имеет имя "/". </font> 
        
        </p></li><li> 
          <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
            Берем первое именованое ребро в пути и записываем его имя, которому 
            предваряем символ "/". </font> 
        
        </p></li><li> 
          <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
            Для каждого очередного именованного ребра в пути приписываем к уже 
            получившейся строке справа символ "/" и имя соответствующего ребра.</font> 
        
      </p></li></ol>
      <br>
    </dir>
    <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> Полное 
      имя является уникальным для всей файловой системы и однозначно определяет 
      соответствующий ему файл.</font> <br>
      &nbsp;<br>
  
  </p></li><li> 
    <p align="justify"> <font color="#ff0000" face="Times New Roman, Times, serif" size="3"><b> 
      <a name="s1104"></a> Организация файла на диске в UNIX на примере файловой 
      системы s5fs. Понятие индексного узла (inode).</b></font> <br>
      <br>
    </p><p align="justify"> <font face="Times New Roman, Times, serif" size="3"> Рассмотрим 
      как организуется на физическом носителе любой файл в UNIX на примере простой 
      файловой системы, впервые появившейся в вариантах операционной системы System 
      V и носящей поэтому название s5fs (<b>S</b>ystem <b>V</b> <b>f</b>ile <b>s</b>ystem). 
      <br>
      <br>
      Все дисковое пространство раздела в файловой системе s5fs логически разделяется 
      на две части: <i>заголовок раздела</i> и <i>логические блоки данных</i>. 
      Заголовок раздела содержит служебную информацию, необходимую для работы 
      файловой системы, и обычно располагается в самом начале раздела. Логические 
      блоки хранят собственно содержательную информацию файлов и часть информации 
      о размещении файлов на диске (т.е. какие логические блоки и в каком порядке 
      содержат информацию, записанную в файл). <br>
      <br>
      <a name="s1104a"></a>
	  <a href="http://cs.mipt.ru/docs/courses/osstud/12/ch12.htm#l120301"><img src="sem11-12_files/bookopen.gif" alt="Метод индексных узлов в лекции" align="right" border="0" height="34" hspace="10" vspace="1" width="48"></a> 
      Для размещения любого файла на диске используется метод <i>индексных узлов</i> 
      (inode - от <b>i</b>ndex <b>node</b>), который был подробно изложен на лекции 
      и на котором здесь мы останавливаться не будем. Индексный узел содержит 
      атрибуты файла и оставшуюся часть информации об его размещении на диске. 
      Необходимо однако отметить, что такие типы файлов, как "связь", 
      "сокет", "устройство", "FIFO" не занимают 
      на диске никакого иного места, кроме индексного узла (им не выделяется логических 
      блоков). Все необходимое для работы с этими типами файлов содержится в их 
      атрибутах.<br>
      &nbsp;<br>
      <a href="http://cs.mipt.ru/docs/courses/osstud/11/ch11.htm#l1104"><img src="sem11-12_files/bookopen.gif" alt="Атрибуты файлов в лекции" align="right" border="0" height="34" hspace="10" vspace="1" width="48"></a> 
      Давайте перечислим часть атрибутов файлов, хранящихся в индексном узле и 
      свойственных для большинства типов файлов. К таким атрибутам относятся:</font> 
      <br>
      <br>
    </p><ul type="square">
      <li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          Тип файла и права различных категорий пользователей для доступа к нему. 
          </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          Идентификаторы владельца-пользователя и владельца-группы. </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          Размер файла в байтах (только для регулярных файлов, директорий и файлов 
          типа "связь"). </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          Время последнего доступа к файлу. </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          Время последней модификации файла. </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          Время последней модификации самого индексного узла. </font> 
      
      <br>
    </p></li></ul>
    <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> Существует 
      еще один атрибут, о котором мы поговорим позже, когда будем рассматривать 
      <a href="#s110809">операцию связывания файлов</a>. <br>
      <br>
      Количество индексных узлов в разделе является постоянной величиной, определяемой 
      на этапе генерации файловой системы. Все индексные узлы системы организованы 
      в виде массива, хранящегося в заголовке раздела. Каждому файлу соответствует 
      только один элемент этого массива и, наоборот, каждому непустому элементу 
      этого массива соответствует только один файл. Таким образом, каждый файл 
      на диске может быть однозначно идентифицирован номером своего индексного 
      узла (его индексом в массиве). <br>
      <br>
      На языке графового представления логической организации файловой системы 
      это означает, что каждому узлу графа соотвествует ровно один номер индексного 
      узла и никакие два узла графа не могут иметь одинаковые номера. <br>
      <br>
      Надо отметить, что свойством уникальности номеров индексных узлов, идентифицирующих 
      файлы, мы уже неявно пользовались при работе с <a href="http://cs.mipt.ru/docs/courses/osstud/05/prep/sem5.htm#s0514">именоваными 
      pip'ами</a> и <a href="http://cs.mipt.ru/docs/courses/osstud/06/prep/sem6-7.htm#s0602">средствами System 
      V IPC</a>. Для именованного pip'a именно номер индексного узла, соответствующего 
      файлу с типом FIFO, является той самой точкой привязки, пользуясь которой 
      различные неродственные процессы могут получить данные об расположении pip'а 
      в адресном пространстве ядра и его состоянии и связаться друг с другом. 
      Для средств System V IPC при генерации <a href="http://cs.mipt.ru/docs/courses/osstud/06/prep/sem6-7.htm#s0603">IPC 
      ключа</a> с помощью функции <a href="http://cs.mipt.ru/docs/courses/osstud/man/ftok.htm">ftok()</a> в действительности 
      используется не имя заданного файла, а номер соответствующего ему индексного 
      дескриптора, который по определенному алгоритму объединяется с номером экземпляра 
      средства связи.<br>
      &nbsp;<br>
      </font> 
  
  </p></li><li> 
    <p align="justify"> <font color="#ff0000" face="Times New Roman, Times, serif" size="3"><b> 
      <a name="s1105"></a> Организация директорий (каталогов) в UNIX. </b></font> 
      <br>
      <br>
    </p><p align="justify"> <font face="Times New Roman, Times, serif" size="3"> <a href="http://cs.mipt.ru/docs/courses/osstud/12/ch12.htm#l1204"><img src="sem11-12_files/bookopen.gif" alt="Организация директорий в лекции" align="right" border="0" height="34" hspace="10" vspace="1" width="48"></a> 
      Содержимое регулярных файлов (информация, находящаяся в них, и способ ее 
      организации) всецело определяется программистом, создающим файл. В отличие 
      от регулярных, остальные типы файлов, содержащих данные, т.&nbsp;е. директории 
      и связи, имеют жестко заданную структуру и содержание, определяемые типом 
      используемой файловой системы. <br>
      <br>
      Основным содержимым файлов типа "директория", если говорить на пользовательском 
      языке, являются имена файлов, лежащих непосредственно в этих директориях, 
      и соответствующие им номера индексных узлов. Более строго, в терминах графового 
      представления, содержимое директорий представляет собой имена ребер, выходящих 
      из узлов, соотвествующих директориям, вместе с индексными номерами узлов, 
      к которым они ведут.<br>
      <br>
      В файловой системе s5fs пространство имен файлов (ребер) содержит имена, 
      не превышающие 14-и символов, а максимальное количество inode в одном разделе 
      файловой системы не может превышать значения 65535. Эти ограничения не позволяют 
      придавать файлам осмысленные имена и приводят к необходимости разбиения 
      больших жестких дисков на несколько разделов. Зато они помогают упростить 
      структуру хранения информации в директории. Все содержимое директории представляет 
      собой таблицу, в которой каждый элемент имеет фиксированный размер в 16 
      байт. Из них 14 байт отводится под имя соответствующего файла (ребра), а 
      2 байта - под номер его индексного узла. При этом первый элемент таблицы 
      дополнительно содержит ссылку на саму данную директорию под именем ".", 
      а второй элемент таблицы - ссылку на родительский каталог, т.е. на узел 
      графа, из которого выходит единственное именованное ребро, ведущее к текущему 
      узлу, (если такой существует) под именем "..".<br>
      <br>
      В более современной файловой системе FFS (Fast File System) размерность 
      пространства имен файлов (ребер) увеличена до 255 символов. Это позволило 
      использовать практически любые мыслимые имена для файлов (вряд ли найдется 
      программист, которому будет не лень набирать для имени более 255 символов), 
      но потребовало изменить структуру каталога (чтобы уменьшить его размеры 
      и не хранить пустые байты). В системе FFS каталог представляет собой таблицу 
      из записей переменной длины. В структуру каждой записи входят: номер индексного 
      узла, длина этой записи, длина имени файла и собственно его имя. Две первых 
      записи в каталоге, как и в s5fs, по прежнему адресуют саму данную директорию 
      и ее родительский каталог.<br>
      &nbsp; <br>
      </font> 
  
  </p></li><li> 
    <p align="justify"> <font color="#ff0000" face="Times New Roman, Times, serif" size="3"><b> 
      <a name="s1106"></a> Понятие суперблока.</b></font><br>
      <br>
    </p><p align="justify"> <font face="Times New Roman, Times, serif" size="3"> Мы 
      с вами уже коснулись содержимого заголовка раздела, когда говорили о массиве 
      индексных узлов файловой системы. <a href="http://cs.mipt.ru/docs/courses/osstud/12/ch12.htm#l120304"><img src="sem11-12_files/bookopen.gif" alt="Суперблок в лекции" align="right" border="0" height="34" hspace="10" vspace="1" width="48"></a> 
      Оставшуюся часть заголовка в s5fs принято называть <i>суперблоком</i>. Суперблок 
      хранит информацию, необходимую для правильного функционирования файловой 
      системы в целом. В нем содержатся, в частности, следующие данные:<br>
      </font><br>
    </p><ul type="square">
      <li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          Тип файловой системы. </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          Флаги состояния файловой системы. </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          Размер логического блока в байтах (обычно кратен 512 байтам). </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          Размер файловой системы в логических блоках (включая сам суперблок и 
          массив inode). </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          Размер массива индексных узлов (т.е. сколько файлов может быть размещено 
          в файловой системе). </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          Число свободных индексных узлов (сколько файлов еще можно создать). 
          </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          Число свободных блоков для размещения данных. </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          Часть списка свободных индексных узлов. </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          Часть списка свободных блоков для размещения данных. </font> 
      
    </p></li></ul>
    <br>
    <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> В 
      некоторых модификациях файловой системы s5fs последние два списка выносятся 
      за пределы суперблока, но остаются в заголовке раздела. При первом же обращении 
      к файловой системе суперблок обычно целиком считывается в адресное пространство 
      ядра для ускорения последующих обращений. Поскольку количество логических 
      блоков и индексных узлов в файловой системе может быть весьма большим, нецелесообразно 
      хранить списки свободных блоков и узлов в суперблоке полностью. При работе 
      с индексными узлами часть списка свободных узлов, находящаяся в суперблоке, 
      постепенно исчерпывается. Когда список близок к исчерпанию, операционная 
      система сканирует массив индексных узлов и заново заполняет список. <a href="http://cs.mipt.ru/docs/courses/osstud/12/ch12.htm#l120302"><img src="sem11-12_files/bookopen.gif" alt="Учет свободных блоков в лекции" align="right" border="0" height="34" hspace="10" vspace="1" width="48"></a> 
      Часть списка свободных логических блоков, лежащая в суперблоке, содержит 
      ссылку на его продолжение, расположенное где-либо в блоках данных. Когда 
      эта часть оказывается использованной, операционная система загружает на 
      освободившееся место продолжение списка, а блок использовавшийся для его 
      хранения переводится в разряд свободных.<br>
      &nbsp; <br>
      </font> 
  
  </p></li><li> 
    <p align="justify"> <font color="#ff0000" face="Times New Roman, Times, serif" size="3"><b> 
      <a name="s1107"></a> Операции над файлами и директориями.</b></font> <br>
      <br>
    </p><p align="justify"> <font face="Times New Roman, Times, serif" size="3"> Хотя 
      с точки зрения пользователя рассмотрение операций над файлами и директориями 
      представляется достаточно простым и сводится к перечислению ряда системных 
      вызовов и команд операционной системы, попытка систематического подхода 
      к набору операций вызывает определенные затруднения. Далее речь у нас пойдет 
      в основном о регулярных файлах и файлах типа "директория".<br>
      <br>
      <a href="http://cs.mipt.ru/docs/courses/osstud/11/ch11.htm#l1105"><img src="sem11-12_files/bookopen.gif" alt="Методы доступа в лекции" align="right" border="0" height="34" hspace="10" vspace="1" width="48"></a> 
      На лекциях мы говорили о том, что существует два основных вида файлов, различающихся 
      по методу доступа: файлы последовательного доступа и файлы прямого доступа. 
      Если рассматривать файлы прямого и последовательного доступа как абстрактные 
      типы данных, то они представляются как нечто, содержащее информацию, над 
      которым можно совершать следующие операции: <br>
      <br>
      </font> 
    </p><ul type="square">
      <li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          Для последовательного доступа: чтение очередной порции данных (<b>read</b>), 
          запись очередной порции данных (<b>write</b>) и позиционирование на 
          начале файла (<b>rewind</b>). </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          Для прямого доступа: чтение очередной порции данных (<b>read</b>), запись 
          очередной порции данных (<b>write</b>) и позиционирование на требуемой 
          части данных (<b>seek</b>). </font> 
      
    </p></li></ul>
    <br>
    <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> Работа 
      с объектами этих абстрактных типов подразумевает наличие еще двух необходимых 
      операций: создание нового объекта (<b>new</b>) и уничтожение уже существующего 
      объекта (<b>free</b>).<br>
      <br>
      Расширение математической модели файла за счет добавления к хранимой информации 
      атрибутов, присущих файлу, (права доступа, учетные данные) влечет за собой 
      появление еще двух операций: прочитать атрибуты (<b>get attribute</b>) и 
      установить их значения (<b>set attribute</b>).<br>
      <br>
      Наделение файлов какой-либо внутренней структурой (как у файла типа "директория") 
      или наложение на набор файлов внешней логической структуры (объединение 
      в ациклический направленный граф) приводит к появлению других наборов операций, 
      составляющих интерфейс работы с файлами, которые тем не менее будут являться 
      комбинациями вышеперечисленных базовых операций. <br>
      <br>
      Для директории, например, такой набор операций, определяемый ее внутренним 
      строением, может выглядеть так: операции <b>new</b>, <b>free</b>, <b>set 
      attribute</b> и <b>get attribute</b> остаются без изменений, а операции<b> 
      read</b>, <b>write</b> и <b>rewind</b> (<b>seek</b>) заменяются на более 
      высокоуровневые: <br>
      <br>
      </font> 
    </p><ul type="square">
      <li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          прочитать запись, соответствующую имени файла, -<b> get record</b>; 
          </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          добавить новую запись - <b>add record</b>; </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          удалить запись, соответствующую имени файла, - <b>delete record</b>; 
          </font> 
      
    </p></li></ul>
    <br>
    <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> <a href="http://cs.mipt.ru/docs/courses/osstud/11/ch11.htm#l1106"><img src="sem11-12_files/bookopen.gif" alt="Операции над файлами  в лекции" align="right" border="0" height="34" hspace="10" vspace="1" width="48"></a> 
      <a href="http://cs.mipt.ru/docs/courses/osstud/11/ch11.htm#l1108"><img src="sem11-12_files/bookopen.gif" alt="Операции над директориями в лекции" align="right" border="0" height="34" hspace="10" vspace="1" width="48"></a> 
      Неполный набор операций над файлами, связанный с их логическим объединением 
      в директорную структуру, будет выглядеть следующим образом:<br>
      <br>
      </font> 
    </p><ul type="square">
      <li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          Операции для работы с атрибутами файлов - <b>get attribute</b>, <b>set 
          attribute</b>. </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          Операции для работы с содержимым файлов - <b> read</b>, <b>write</b>, 
          <b>rewind</b>(<b>seek</b>) для регулярных файлов и <b>get record</b>, 
          <b>add record</b>, <b>delete record</b> для директорий.</font> 
      
      </p></li><li> 
        <p align="justify"><font face="Times New Roman, Times, serif" size="3"> 
          Операция создания регулярного файла в некоторой директории (создание 
          нового узла графа и добавление в граф нового именованного ребра, ведущего 
          в этот узел из некоторого узла, соответствующего директории) - <b>create</b>. 
          Эту операцию можно рассматривать как суперпозицию двух операций: базовой 
          операции <b>new</b> для регулярного файла и <b>add record</b> для соответствующей 
          директории.</font> 
      
      </p></li><li> 
        <p align="justify"><font face="Times New Roman, Times, serif" size="3"> 
          Операция создания поддиректории в некоторой директории - <b>make directory</b>. 
          Эта операция отличается от предыдущей операции <b>create</b> занесением 
          в файл новой директории информации о файлах с именами "." 
          и "..", т.е. по сути дела она есть суперпозиция операции <b>create</b> 
          и двух операций <b>add record</b>.</font> 
      
      </p></li><li> 
        <p align="justify"><font face="Times New Roman, Times, serif" size="3"> 
          Операция создания файла типа "связь" - <b>symbolic link</b>. </font> 
      
      </p></li><li> 
        <p align="justify"><font face="Times New Roman, Times, serif" size="3"> 
          Операция создания файла типа "FIFO" - <b>make FIFO</b>. </font> 
      
      </p></li><li> 
        <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
          Операция добавления к графу нового именованного ребра, ведущего от узла, 
          соответствующего директории, к узлу, соответствующему любому другому 
          типу файла, - <b>link</b>. Это просто <b>add record</b> с некоторыми 
          ограничениями.</font> 
      
      </p></li><li> 
        <p align="justify"><font face="Times New Roman, Times, serif" size="3"> 
          Операция удаления файла, не являющегося директорией или "связью" 
          (удаление именованного ребра из графа, ведущего к терминальной вершине 
          с одновременным удалением этой вершины, если к ней больше не ведет именованных 
          ребер), - <b>unlink</b>.</font> 
      
      </p></li><li> 
        <p align="justify"><font face="Times New Roman, Times, serif" size="3"> 
          Операция удаления файла типа "связь" (удаление именованного 
          ребра, ведущего к узлу, соответствующему файлу типа "связь", 
          с одновременным удалением этого узла и выходящего из него неименованного 
          ребра, если к этому узлу больше не ведет именованных ребер), - <b>unlink 
          link</b>.</font> 
      
      </p></li><li> 
        <p align="justify"><font face="Times New Roman, Times, serif" size="3"> 
          Операция рекурсивного удаления директории со всеми входящими в нее файлами 
          и поддиректориями - <b>remove directory</b></font>. 
      
      </p></li><li> 
        <p align="justify"><font face="Times New Roman, Times, serif" size="3"> 
          Операция переименования файла (ребра графа) - <b>rename</b>. </font> 
      
      </p></li><li> 
        <p align="justify"><font face="Times New Roman, Times, serif" size="3"> 
          Операция перемещения файла из одной директории в другую (перемещается 
          точка выхода именованного ребра, которое ведет к узлу, соответствующему 
          данному файлу) - <b>move</b>. </font> 
      
    </p></li></ul>
    <br>
    <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> Возможны 
      и другие подобные операции. <br>
      <br>
      Способ реализации файловой системы в реальной операционной системе также 
      может добавлять новые операции. Если часть информации файловой системы или 
      отдельного файла кэшируются в адресном пространстве ядра, то появляются 
      операции синхронизации данных в кэше и на диске для всей системы в целом 
      (<b>sync</b>) и для отдельного файла (<b>sync file</b>). <br>
      <br>
      Естественно, что все перечисленные операции могут быть выполнены процессом 
      только при наличии у него определенных полномочий (прав доступа и т.д.). 
      Для выполнения операций над файлами и директориями операционная система 
      предоставляет процессам интерфейс в виде системных вызовов, библиотечных 
      функций и команд операционной системы. Часть этих системных вызовов, функций 
      и команд мы рассмотрим в следующих разделах. <br>
      &nbsp; <br>
      </font> 
  
  </p></li><li> 
    <p align="justify"> <font color="#ff0000" face="Times New Roman, Times, serif" size="3"><b> 
      <a name="s1108"></a> Системные вызовы и команды для выполнения операций 
      над файлами и директориями.</b></font> <br>
      <br>
    </p><p align="justify"> <font face="Times New Roman, Times, serif" size="3"> На 
      предыдущих семинарах мы уже говорили о некоторых командах и системных вызовах, 
      позволяющих выполнять операции над файлами в операционной системе UNIX.<br>
      <br>
      На <a href="http://cs.mipt.ru/docs/courses/osstud/01/prep/sem1-2.htm">семинарах 1-2</a> мы рассмотрели ряд 
      команд, позволяющих изменять атрибуты файла - <a href="http://cs.mipt.ru/docs/courses/osstud/man/chmod.htm">chmod</a>, 
      <a href="http://cs.mipt.ru/docs/courses/osstud/man/chown.htm">chown</a>, <a href="http://cs.mipt.ru/docs/courses/osstud/man/chgrp.htm">chgrp</a> 
      команду копирования файлов и директорий - <a href="http://cs.mipt.ru/docs/courses/osstud/man/cp.htm">cp</a>, 
      команду удаления файлов и директорий -<a href="http://cs.mipt.ru/docs/courses/osstud/01/prep/sem1-2.htm#s0114a"> 
      rm</a>, команду переименования и перемещения файлов и директорий - <a href="http://cs.mipt.ru/docs/courses/osstud/man/mv.htm">mv</a>, 
      команду просмотра содержимого директорий - <a href="http://cs.mipt.ru/docs/courses/osstud/01/prep/sem1-2.htm#s0110a">ls</a>.<br>
      <br>
      На <a href="http://cs.mipt.ru/docs/courses/osstud/05/prep/sem5.htm">семинаре 5</a>, посвященном потокам 
      ввода-вывода, мы говорили о хранении информации о файлах внутри адресного 
      пространства процесса с помощью <a href="http://cs.mipt.ru/docs/courses/osstud/05/prep/sem5.htm#s0503">таблицы 
      открытых файлов</a>, о понятии <a href="http://cs.mipt.ru/docs/courses/osstud/05/prep/sem5.htm#s0503">файлового 
      дескриптора</a>, о необходимости введения <a href="http://cs.mipt.ru/docs/courses/osstud/05/prep/sem5.htm#s0504">операций 
      открытия</a> и закрытия файлов (системные вызовы <a href="http://cs.mipt.ru/docs/courses/osstud/man/open.htm">open()</a> 
      и <a href="http://cs.mipt.ru/docs/courses/osstud/man/close.htm">close()</a>) и об операциях чтения и записи 
      (системные вызовы <a href="http://cs.mipt.ru/docs/courses/osstud/man/read.htm">read()</a> и <a href="http://cs.mipt.ru/docs/courses/osstud/man/read.htm">write()</a>). 
      Мы обещали вернуться к более подробному рассмотрению затронутых вопросов 
      на текущих семинарах. Пора выполнять обещанное. Далее в этом разделе, если 
      не будет оговоренно особо, под словом файл будет подразумеваться регулярный 
      файл.<br>
      <br>
      Вся информация об атрибутах файла и его расположении на физическом носителе 
      содержится в соответствующем файлу индексном узле и, возможно, в нескольких 
      логических блоках, связанных с индексным узлом. Для того, чтобы при каждой 
      операции над файлом не считывать эту информацию с физического носителя заново, 
      кажется логичным, считав ее один раз при первом обращении к файлу, хранить 
      ее в адресном пространстве процесса или в части адресного пространства ядра, 
      характеризующей данный процесс. <a href="http://cs.mipt.ru/docs/courses/osstud/02/ch2.htm#l020302"> <img src="sem11-12_files/bookopen.gif" alt="PCB и контекст процесса в лекции" align="right" border="0" hspace="10" vspace="1"></a> 
      Именно поэтому на одной <a href="http://cs.mipt.ru/docs/courses/osstud/02/l2.htm">из первых лекций</a> мы 
      отнесли данные о файлах, используемых процессом, к составу системного контекста 
      процесса, содержащегося в его PCB. <br>
      <br>
      <a name="s1108a"></a>С точки зрения пользовательского процесса каждый файл 
      представляет собой линейный набор байт, снабженный <i>указателем текущей 
      позиции</i> процесса в этом наборе. Все операции чтения из файла и записи 
      в файл производятся в этом наборе с места, на которое показывает указатель 
      текущей позиции. После операции чтения или записи указатель текущей позиции 
      помещается после конца прочитанного или записанного участка файла. Значение 
      этого указателя является динамической характеристикой файла для использующего 
      его процесса и также хранится в PCB. <br>
      <br>
      Некоторые файлы могут использоваться одновременно более чем одним процессом. 
      Для того, чтобы не хранить дублирующуюся информацию об атрибутах файлов 
      и их расположении для каждого процесса отдельно, такие данные обычно размещаются 
      в адресном пространстве ядра операционной системы в единственном экземпляре, 
      а доступ к ним процессы получают только при выполнении соотвествующих системных 
      вызовов для операций над файлами. <br>
      <br>
      <a name="s1108b"></a>Как видим, вся информация о файле, необходимая процессу 
      для работы с ним, может быть разбита на две части: данные, специфичные для 
      этого процесса, - например, указатель текущей позиции, и данные, являющиеся 
      общими для различных процессов, - атрибуты и расположение файла. Естественно, 
      что для хранения этой информации применяются две различные связанные структуры 
      данных, лежащие, как правило, в адресном пространстве ядра операционной 
      системы, - <i>системная таблица файлов</i> и <i>таблица индексных узлов 
      открытых файлов</i>. Для доступа к этой информации в управляющем блоке процесса 
      заводится таблица открытых файлов, каждый непустой элемент которой содержит 
      ссылку на структуру, хранящую данные о файле, характерные для данного процесса, 
      и из которой, в свою очередь, мы можем по ссылке доступиться к общим данным 
      о файле. Индекс элемента в этой таблице (небольшое целое неотрицательное 
      число) или файловый дескриптор является той величиной, характеризующей файл, 
      которой может оперировать процесс при работе на уровне пользователя. В эту 
      же таблицу открытых файлов помещаются и ссылки на данные, описывающие другие 
      потоки ввода-вывода, такие как pipe и FIFO (об этом мы уже говорили на <a href="http://cs.mipt.ru/docs/courses/osstud/05/prep/sem5.htm">семинаре 
      5</a>). Как мы увидим позже (на <a href="http://cs.mipt.ru/docs/courses/osstud/15/prep/sem15-16.htm">семинарах, 
      посвященных сетевому программированию</a>), эта же таблица будет использоваться 
      и для размещения ссылок на структуры данных, необходимых для передачи информации 
      от процесса к процессу по сети.<br>
      <br>
      <b><a name="s110801"></a>Системный вызов open().</b> Для выполнения большинства 
      операций над файлами через системные вызовы пользовательский процесс обычно 
      должен указать в качестве одного из параметров системного вызова дескриптор 
      файла, над которым нужно совершить операцию. Поэтому, прежде чем совершать 
      операции, мы должны поместить информацию о файле в наши таблицы файлов и 
      определить соответствующий файловый дескриптор. Для этого, <a href="http://cs.mipt.ru/docs/courses/osstud/05/prep/sem5.htm#s0504">как 
      мы уже говорили</a>, применяется процедура открытия файла, осуществляемая 
      системным вызовом <a href="http://cs.mipt.ru/docs/courses/osstud/man/open.htm">open()</a>. При открытии 
      файла операционная система проверяет, соотвествуют ли права, которые запросил 
      процесс для операций над файлом, правам доступа, установленным для этого 
      файла. В случае соответсвия, она помещает необходимую информацию в системную 
      таблицу файлов и, если этот файл не был ранее открыт другим процессом, в 
      таблицу индексных дескрипторов открытых файлов, устанавливает необходимую 
      связь между всеми тремя таблицами и возвращает на пользовательский уровень 
      дескриптор этого файла.<br>
      <br>
      По сути дела, с помощью операции открытия файла операционная система осуществляет 
      отображение из пространства имен файлов в дисковое пространство файловой 
      системы, подготавливая почву для совершения других операций. <br>
      <br>
      <b><a name="s110802"></a>Системный вызов close().</b> Обратным системным 
      вызовом, по отношению к системному вызову <a href="http://cs.mipt.ru/docs/courses/osstud/man/open.htm">open()</a>, 
      является системный вызов <a href="http://cs.mipt.ru/docs/courses/osstud/man/close.htm">close()</a>, с которым 
      мы тоже <a href="http://cs.mipt.ru/docs/courses/osstud/05/prep/sem5.htm#s0505a">уже знакомились</a>. После 
      завершения работы с файлом процесс освобождает выделенные ресурсы операционной 
      системы и, возможно, синхронизирует информацию о файле, содержащуюся в таблице 
      индексных узлов открытых файлов, с информацией на диске, используя этот 
      системный вызов. Надо отметить, что место в таблице индексных узлов открытых 
      файлов не освобождается по системному вызову <a href="http://cs.mipt.ru/docs/courses/osstud/man/close.htm">close()</a> 
      до тех пор, пока в системе существует хотя бы один процесс, использующий 
      этот файл. Для обеспечения такого поведения в ней для каждого индексного 
      узла заводится счетчик числа открытий, увеличивающийся на 1 при каждом системном 
      вызове <a href="http://cs.mipt.ru/docs/courses/osstud/man/open.htm">open()</a> для данного файла и уменьшающийся 
      на 1 при каждом его закрытии. Очищение элемента таблицы индексных узлов 
      открытых файлов с окончательной синхронизацией данных в памяти и на диске 
      происходит только в том случае, если при очередном закрытии файла этот счетчик 
      становится равным 0.<br>
      <br>
      Поведение таблицы открытых файлов процесса и связанных с ней таблиц при 
      системных вызовах <a href="http://cs.mipt.ru/docs/courses/osstud/man/exit.htm">exit()</a>, <a href="http://cs.mipt.ru/docs/courses/osstud/man/exec.htm">exec()</a> 
      и <a href="http://cs.mipt.ru/docs/courses/osstud/man/fork.htm">fork()</a> мы обсуждали на <a href="http://cs.mipt.ru/docs/courses/osstud/05/prep/sem5.htm">семинаре 
      5</a>. <br>
      <br>
      <b><a name="s110803"></a>Операция создания файла. Системный вызов creat().</b> 
      При обсуждении системного вызова <a href="http://cs.mipt.ru/docs/courses/osstud/man/open.htm">open()</a> 
      мы подробно говорили о его использовании для создания нового файла. Для 
      этих же целей можно использовать системный вызов <a href="http://cs.mipt.ru/docs/courses/osstud/man/creat.htm">creat()</a>, 
      являющийся, по существу, урезанным вариантом вызова <a href="http://cs.mipt.ru/docs/courses/osstud/man/open.htm">open()</a> 
      (о значение флага <b><font color="#008000">O_TRUNC</font></b> для системного 
      вызова <a href="http://cs.mipt.ru/docs/courses/osstud/man/open.htm">open()</a> см. чуть ниже).<br>
      <br>
      <b><a name="s110804"></a>Операция чтения атрибутов файла. Системные вызовы 
      stat(), fstat() и lstat().</b> Для чтения всех атрибутов файла в специальную 
      структуру могут применяться системные вызовы <a href="http://cs.mipt.ru/docs/courses/osstud/man/stat.htm">stat(), 
      fstat() и lstat()</a>. Разъяснение понятий жесткая и мягкая (символическая) 
      связь, встречающихся в описании системных вызовов, будет дано позже при 
      рассмотрении <a href="#s110809">операций связывания файлов</a>.<br>
      <br>
      <b><a name="s110805"></a>Операции изменения атрибутов файла.</b> Большинство 
      операций изменения атрибутов файла обычно выполняется пользователем в интерактивном 
      режиме с помощью команд операционной системы. Мы уже говорили о них на <a href="http://cs.mipt.ru/docs/courses/osstud/01/prep/sem1-2.htm">семинарах 
      1-2</a> и не будем возвращаться к ним вновь. Отметим только операцию изменения 
      размеров файла, а точнее операцию его обрезания, без изменения всех других 
      атрибутов, кроме, быть может, времен последнего доступа к файлу и его последней 
      модификации. Для того, чтобы уменьшить размеры существующего файла до 0, 
      не затрагивая его остальных характеристик (прав доступа, даты создания, 
      учетной информации и т.д.), можно при открытии файла использовать в комбинации 
      флагов системного вызова <a href="http://cs.mipt.ru/docs/courses/osstud/man/open.htm">оpen()</a> флаг <b><font color="#008000">O_TRUNC</font></b>. 
      Для изменения размеров файла до любой желаемой величины (даже для его увеличения 
      во многих вариантах UNIX, хотя изначально этого не предусматривалось!) может 
      служить системный вызов <a href="http://cs.mipt.ru/docs/courses/osstud/man/ftruncat.htm">ftruncate()</a>. 
      При этом, если размер файла мы уменьшаем, то вся не влезающая в новый размер 
      информация в конце файла будет потеряна, если же размер файла мы увеличиваем, 
      то это будет выглядеть так, как будто мы дополнили его до недостающего размера 
      нулевыми битами. <br>
      <br>
      <b><a name="s110806"></a>Операции чтения из файла и записи в файл.</b> <img src="sem11-12_files/znak.gif" alt="Nota bene" align="left" border="0" hspace="10" vspace="8"> 
      Для операций чтения из файла и записи в файл применяются системные вызовы 
      <a href="http://cs.mipt.ru/docs/courses/osstud/man/read.htm">read()</a> и <a href="http://cs.mipt.ru/docs/courses/osstud/man/read.htm">write()</a>, 
      которые мы уже обсуждали <a href="http://cs.mipt.ru/docs/courses/osstud/04/prep/sem4.htm#s0405">ранее</a>. 
      <b>Надо отметить, что их поведение при работе с файлами имеет <a href="http://cs.mipt.ru/docs/courses/osstud/man/read.htm#read0">определенные 
      особенности</a>, связанные с понятием <a href="#s1108a">указателя текущей 
      позиции</a> в файле.</b> <br>
      <br>
      <b><a name="s110807"></a>Операция изменения указателя текущей позиции. Системный 
      вызов lseek().</b> С точки зрения процесса все регулярные файлы являются 
      файлами прямого доступа. В любой момент процесс может изменить положение 
      указателя текущей позиции в открытом файле с помощью системного вызова <a href="http://cs.mipt.ru/docs/courses/osstud/man/lseek.htm">lseek()</a>. 
      <b><img src="sem11-12_files/znak.gif" alt="Nota bene" align="left" border="0" hspace="10" vspace="8"> 
      Особенностью этого системного вызова является возможность помещения указателя 
      текущей позиции в файле за конец файла (т.е. возможность установления значения 
      указателя большего, чем длина файла).</b> При любой последующей операции 
      записи в таком положении указателя файл будет выглядеть так, как будто возникший 
      промежуток от конца файла до текущей позиции, где начинается запись, был 
      заполнен нулевыми битами. Если операции записи в таком положении указателя 
      не производится, то никакого изменения файла, связанного с необычным значением 
      указателя, не произойдет (например, операция чтения будет возвращать нулевое 
      значение для количества прочитанных байтов).<br>
      <br>
      <b> <a name="s110808"></a>Операция добавления информации в файл. Флаг O_APPEND.</b> 
      Хотя эта операция по сути дела является комбинацией двух уже рассмотренных 
      операций, мы считаем нужным упомянуть ее особо. <img src="sem11-12_files/znak.gif" alt="Nota bene" align="left" border="0" hspace="10" vspace="8"> 
      Если открытие файла системным вызовом <a href="http://cs.mipt.ru/docs/courses/osstud/man/open.htm">open()</a> 
      производилось с установленным флагом<b><font color="#008000"> O_APPEND</font></b>, 
      то любая операция записи в файл <b> будет всегда добавлять новые данные 
      в конец файла</b>, независимо от предыдущего положения указателя текущей 
      позиции (так, как если бы непосредственно перед записью был выполнен вызов 
      <a href="http://cs.mipt.ru/docs/courses/osstud/man/lseek.htm">lseek()</a> для установки указателя на конец 
      файла).<br>
      <br>
      <b><a href="http://cs.mipt.ru/docs/courses/osstud/12/ch12.htm#l1206"><img src="sem11-12_files/bookopen.gif" alt="Создание связей в лекции" align="right" border="0" height="34" hspace="10" vspace="1" width="48"></a> 
      <a name="s110809"></a>Операции создания связей. Команда ln, системные вызовы 
      link() и symlink().</b> С операциями, позволяющими изменять логическую структуру 
      файловой системы, такими как, скажем создание файла, мы уже сталкивались 
      в этом разделе. Однако операции создания связи служат для проведения новых 
      именованных ребер в уже существующей структуре без добавления новых узлов 
      или для опосредованного проведения именованного ребра к уже существующему 
      узлу через файл типа "связь" и неименованное ребро. Такие операции 
      мы с вами до сих пор не рассматривали, поэтому давайте остановимся на них 
      подробнее. <br>
      <br>
      Допустим, что несколько программистов совместно ведут работу над одним и 
      тем же проектом. Файлы, относящиеся к этому проекту, вполне естественно 
      могут быть выделены в отдельную директорию так, чтобы не смешиваться с файлами 
      других пользователей и другими файлами программистов, участвующих в проекте. 
      Для удобства работы каждый из разработчиков, конечно, хотел бы, чтобы эти 
      файлы находились в его собственной поддиректории. Подобного можно было бы 
      добиться, копируя по мере изменения новые версии соответствующих файлов 
      из поддиректории одного исполнителя в поддиректорию другого исполнителя. 
      Однако тогда, во-первых, возникнет ненужное дублирование информации на диске, 
      во-вторых, появится необходимость решения тяжелой задачи синхронизации обновления 
      всех копий этих файлов новыми версиями. <br>
      <br>
      Существует другое решение этой проблемы. Достаточно разрешить файлам иметь 
      несколько имен. Тогда одному физическому экземпляру данных на диске могут 
      соответствовать различные имена файла, находящиеся в одной или в разных 
      директориях. Подобная операция присвоения нового имени файлу (без уничтожения 
      ранее существовашего имени) получила название операции создания связи. <br>
      <br>
      В операционной системе UNIX связь может быть создана двумя различными способами. 
      <br>
      <br>
      Первый способ, наиболее точно следующий описанной выше процедуре, получил 
      название способа создания <i>жесткой связи&nbsp;(hard link)</i>. С точки 
      зрения логической структуры файловой системы этому способу соответствует 
      проведение нового именованного ребра из узла, соответствующего некоторой 
      директории, к узлу, соответствующему файлу любого типа, получающему дополнительное 
      имя. С точки зрения структур данных, описывающих строение файловой системы, 
      в эту директорию добавляется запись, содержащая дополнительное имя файла 
      и номер его индексного узла (уже существующего!). При таком подходе и новое 
      имя файла, и его старое имя или имена абсолютно равноправны для операционной 
      системы и могут взаимозаменяемо использоваться для осуществления всех операций.<br>
      <br>
      Использование жестких связей приводит к возникновению двух проблем.<br>
      <br>
      <a name="s110809a"></a>Первая проблема связана с операцией удаления файла. 
      Если мы хотим удалить файл из некоторой директории, то после удаления из 
      ее содержимого записи, соответствующей этому файлу, мы не можем освободить 
      логические блоки, занимаемые файлом, и его индексный узел, не убедившись, 
      что у файла нет дополнительных имен (к его индексному узлу не ведут ссылки 
      из других директорий), иначе мы нарушим целостность файловой системы. Для 
      решения этой проблемы файлы получают дополнительный атрибут - счетчик жестких 
      связей (или именованых ребер), ведущих к ним, который, как и другие атрибуты, 
      располагается в их индексных узлах. При создании файла этот счетчик получает 
      значение 1. При создании каждой новой жесткой связи, ведущей к файлу, он 
      увеличивается на 1. Когда мы удаляем файл из некоторой директории, то из 
      ее содержимого удаляется запись об этом файле, и счетчик жестких связей 
      уменьшается на 1. Если его значение становится равным 0, происходит освобождение 
      логических блоков и индексного узла, выделенных этому файлу.<br>
      <br>
      Вторая проблема связана с опасностью превращения логической структуры файловой 
      системы из ациклического графа в циклический и с возможной неопределенностью 
      толкования записи с именем ".." в содержимом директорий. Для их 
      предотвращения во всех существующих вариантах операционной системы UNIX 
      запрещено создание жестких связей, ведущих к уже существующим директориям 
      (несмотря на то, что POSIX стандарт для операционной системы UNIX разрешает 
      подобную операцию для суперпользователей). Поэтому мы и говорили о том, 
      что в узел, соответствующий файлу типа "директория", не может 
      вести более одного именованого ребра. (В операционной системе Linux по непонятной 
      причине дополнительно запрещено создание жестких связей, ведущих к специальным 
      файлам устройств.)<br>
      <br>
      Для создания жестких связей применяются команда операционной системы <a href="http://cs.mipt.ru/docs/courses/osstud/man/ln.htm">ln</a> 
      без опций и системный вызов <a href="http://cs.mipt.ru/docs/courses/osstud/man/link.htm">link()</a>. <b> 
      <img src="sem11-12_files/znak.gif" alt="Nota bene" align="left" border="0" hspace="10" vspace="8">Надо 
      отметить, что системный вызов <a href="http://cs.mipt.ru/docs/courses/osstud/man/link.htm">link()</a> является 
      одним из немногих системных вызовов, совершающих операции над файлами, которые 
      не требуют предварительного открытия файла, поскольку он подразумевает выполнение 
      единичного действия только над содержимым индексного узла, выделенного связываемому 
      файлу.<br>
      </b> <br>
      Второй способ создания связи получил название способа создания <i>мягкой 
      (soft)</i> или <i>символической (symbolic) связи (link)</i>. В то время 
      как жесткая связь файлов является аналогом использования прямых ссылок (указателей) 
      в современных языках программирования, символическая связь, до некоторой 
      степени, напоминает косвенные ссылки (указатель на указатель). При создании 
      мягкой связи с именем <b>symlink</b> из некоторой директории к файлу, заданному 
      полным или относительным именем <b>linkpath</b>, в этой директории действительно 
      создается <u><b>новый файл типа "связь"</b></u> с именем <b>symlink</b> 
      со своими собственными индексным узлом и логическими блоками. При тщательном 
      рассмотрении можно обнаружить, что все его содержимое составляет только 
      символьная запись имени <b>linkpath</b>. Операция открытия файла типа "связь" 
      устроена таким образом, что в действительности открывается не сам этот файл, 
      а тот файл, чье имя содержится в нем (при необходимости рекурсивно!). Поэтому 
      операции над файлами, требующие предварительного открытия файла (как, впрочем, 
      и большинство команд операционной системы, совершающих действия над файлами, 
      где операция открытия файла присутствует, но скрытно от пользователя), в 
      реальности будут совершаться не над файлом типа "связь", а над 
      тем файлом, имя которого содержится в нем (или над тем файлом, который в 
      конце концов откроется при рекурсивных ссылках). Отсюда, в частности, следует, 
      что попытки прочитать <u><b>реальное</b></u> содержимое файлов типа "связь" 
      с помощью системного вызова <a href="http://cs.mipt.ru/docs/courses/osstud/man/read.htm">read()</a> обречены 
      на неудачу. Как видно, создание мягкой связи, с точки зрения изменения логической 
      структуры файловой системы, эквивалентно опосредованному проведению именованного 
      ребра к уже существующему узлу через файл типа "связь" и неименованное 
      ребро.<br>
      <br>
      Создание символической связи&nbsp;не приводит к проблеме, связанной с удалением 
      файлов. Если файл, на который ссылается мягкая связь, удаляется с физического 
      носителя, то попытка открытия файла мягкой связи (а, следовательно, и удаленного 
      файла) приведет к ошибке "Файл с таким именем не существует", 
      которая может быть аккуратно обработана приложением, т.е. удаление связанного 
      объекта, как упоминалось ранее, лишь отчасти и нефатально нарушит целостность 
      файловой системы.<br>
      <br>
      Неаккуратное использование символических связей пользователями операционной 
      системы может привести к превращению логической структуры файловой системы 
      из ациклического графа в циклический граф. Это конечно нежелательно, но 
      не носит столь разрушительного характера, как циклы, которые могли бы быть 
      созданы жесткой связью, если бы не был введен запрет на образование жестких 
      связей к директориям. Поскольку мягкие связи принципиально отличается от 
      жестких связей и связей, возникающих между директорией и файлом при его 
      создании, мягкая связь легко может быть идентифицирована операционной системой 
      или программой пользователя. Для предотвращения зацикливания программ, выполняющих 
      операции над файлами, обычно ограничивается глубина рекурсии по прохождению 
      мягких связей. Превышение этой глубины приводит к возникновению ошибки "Слишком 
      много мягких связей", которая может быть легко обработана приложением. 
      Поэтому ограничения на тип файлов, к которым может вести мягкая связь, в 
      операционной системе UNIX не вводятся.<br>
      <br>
      <img src="sem11-12_files/znak.gif" alt="Nota bene" align="left" border="0" hspace="10" vspace="8"> 
      Для создания мягких связей применяются уже знакомая нам команда операционной 
      системы <a href="http://cs.mipt.ru/docs/courses/osstud/man/ln.htm">ln</a> с опцией <b><font color="#008000">-s</font></b> 
      и системный вызов <a href="http://cs.mipt.ru/docs/courses/osstud/man/symlink.htm">symlink()</a>. <b> Надо 
      отметить, что системный вызов <a href="http://cs.mipt.ru/docs/courses/osstud/man/symlink.htm">symlink()</a> 
      также не требует предварительного открытия связываемого файла, поскольку 
      он вообще не рассматирвает его содержимое.</b> <br>
      <br>
      <b><a name="s110810"></a>Операция удаления связей и файлов. Системный вызов 
      unlink().</b> При рассмотрении операции связывания файлов мы уже почти полностью 
      рассмотрели, как собственно производится операция удаления жестких связей 
      и файлов. При удалении мягкой связи, т.е. фактически файла типа "связь", 
      все происходит, как и для обычных файлов. Единственным изменением, с точки 
      зрения логической структуры файловой системы, является то, что при действительном 
      удалении узла, соответствующего файлу типа "связь", вместе с ним 
      удаляется и выходящее из него неименованное ребро. <img src="sem11-12_files/znak.gif" alt="Nota bene" align="left" border="0" hspace="10" vspace="8"> 
      <b>Дополнительно необходимо отметить, что условием реального удаления регулярного 
      файла с диска является не только равенство 0 значения его счетчика жестких 
      связей, но и отсутствие процессов, держащих этот файл открытым.</b> Если 
      такие процессы есть, то удаление регулярного файла произойдет в ходе его 
      полного закрытия последним использующим файл процессом.<br>
      <br>
      <img src="sem11-12_files/znak.gif" alt="Nota bene" align="left" border="0" hspace="10" vspace="8"> 
      Для осуществления операции удаления жестких связей и/или файлов можно использовать 
      уже известную вам с <a href="http://cs.mipt.ru/docs/courses/osstud/01/prep/sem1-2.htm">семинаров 1-2</a> 
      команду операционной системы <a href="http://cs.mipt.ru/docs/courses/osstud/man/rm.htm">rm</a> или системный 
      вызов <a href="http://cs.mipt.ru/docs/courses/osstud/man/unlink.htm">unlink()</a>. <b> Заметим, что системный 
      вызов <a href="http://cs.mipt.ru/docs/courses/osstud/man/unlink.htm">unlink()</a> также не требует предварительного 
      открытия удаляемого файла, поскольку после его удаления совершать над ним 
      операции бессмысленно.</b> <br>
      <br>
      </font> 
  
  </p></li><li> 
    <p align="justify"> <font color="#ff0000" face="Times New Roman, Times, serif" size="3"><b> 
      <a name="s1109"></a> Практическое применение команд и системных вызовов 
      для операций над файлами. </b></font> <br>
      <br>
    </p><p align="justify"> <font face="Times New Roman, Times, serif" size="3"> Практическое 
      использование изученных вызовов и команд на 5-10 минут по усмотрению преподавателя. 
      Обязательно посоздавать жесткие и символические связи и посмотреть содержимое 
      директорий со связями с помощью команды <a href="http://cs.mipt.ru/docs/courses/osstud/man/ls.htm">ls -al</a>. 
      Показать отличие мягких и жестких связей в листинге этой команды.<br>
      <br>
      <font face="Times New Roman, Times, serif" size="2"><b><u>Задача повышенной 
      сложности:</u></b> определите допустимую глубину рекурсии символических 
      связей для вашей операционной системы. </font> </font> <br>
      &nbsp; <br>
  
  </p></li><li> 
    <p align="justify"> <font color="#ff0000" face="Times New Roman, Times, serif" size="3"><b> 
      <a name="s1110"></a> Специальные функции для работы с содержимым директорий. 
      </b></font> <br>
      <br>
    </p><p align="justify"> <font face="Times New Roman, Times, serif" size="3"> Стандартные 
      системные вызовы <a href="http://cs.mipt.ru/docs/courses/osstud/man/open.htm">open()</a>, <a href="http://cs.mipt.ru/docs/courses/osstud/man/read.htm">read()</a> 
      и <a href="http://cs.mipt.ru/docs/courses/osstud/man/close.htm">close()</a> не могут помочь программисту 
      изучить содержимое файла типа "директория". Для анализа содержимого директорий 
      используется набор функций из стандартной библиотеки языка C.<br>
      <br>
      С точки зрения программиста в этом интерфейсе директория представляется 
      как файл последовательного доступа, над которым можно совершать операции 
      чтения очередной записи и позиционирования на начале файла. Перед выполнением 
      этих операций директорию необходимо открыть, а после окончания - закрыть.<br>
      <br>
      Для открытия директории служит функция <a href="http://cs.mipt.ru/docs/courses/osstud/man/opendir.htm">opendir()</a>, 
      которая подготавливает почву для совершения операций и позиционирует нас 
      на начале файла. Чтение очередной записи из директории осуществляет функция 
      <a href="http://cs.mipt.ru/docs/courses/osstud/man/readdir.htm">readdir()</a>, одновременно позиционируя 
      нас на начале следующей записи (если она, конечно, существует). Для операции 
      нового позиционирования на начале директории (если вдруг понадобится) применяется 
      функция <a href="http://cs.mipt.ru/docs/courses/osstud/man/rewinddr.htm">rewinddir()</a>. После окончания 
      работы с директорией ее необходимо закрыть с помощью функции <a href="http://cs.mipt.ru/docs/courses/osstud/man/closedir.htm">closedir()</a>.<br>
      <br>
      &nbsp; <br>
      </font> 
  
  </p></li><li> 
    <p align="justify"> <font color="#ff0000" face="Times New Roman, Times, serif" size="3"><b> 
      <a name="s1111"></a> Написание, прогон и компиляция программы, анализирующей 
      содержимое директории. </b> <br>
      <br>
      </font> 
    </p><p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
      Напишите, откомпилируйте и прогоните программу, распечатывающую список файлов, 
      входящих в директорию, с указанием их типов. Имя директории задается как 
      параметр командной строки. Если оно отсутствует, то выбирается текущая директория.<br>
      <br>
      <font face="Times New Roman, Times, serif" size="2"><b><u>Задача повышенной 
      сложности:</u></b> напишите программу, распечатывающую содержимое заданной 
      директории в формате аналогичном формату выдачи команды <a href="http://cs.mipt.ru/docs/courses/osstud/man/ls.htm">ls 
      -al</a>. Для этого вам дополнительно понадобится самостоятельно изучить 
      в UNIX Manual функцию ctime(3) и системные вызовы time(2), readlink(2). 
      </font> <br>
      &nbsp; <br>
      </font> 
  
  </p></li><li> 
    <p align="justify"> <font color="#ff0000" face="Times New Roman, Times, serif" size="3"><b> 
      <a name="s1112"></a> Понятие о файлах, отображаемых в память (memory mapped 
      файлах). Системные вызовы mmap(), munmap(). </b> <br>
      <br>
      </font> 
    </p><p align="justify"> <font face="Times New Roman, Times, serif" size="3"> Мы 
      уже говорили, что с помощью системного вызова <a href="http://cs.mipt.ru/docs/courses/osstud/man/open.htm">open()</a> 
      операционная система отображает файл из пространства имен в дисковое пространство 
      файловой системы, подготавливая почву для осуществления других операций. 
      С появлением концепции виртуальной памяти, которую мы обсуждали на соответствующей 
      лекции, когда физические размеры памяти перестали играть роль сдерживающего 
      фактора в развитии вычислительных систем, стало возможным отображать файлы 
      непосредственно в адресное пространство процессов. Иными словами, появилась 
      возможность работать с файлами как с обычной памятью, заменив выполнение 
      базовых операций над ними с помощью системных вызовов на использование операций 
      обычных языков программирования. Файлы, чье содержимое отображается непосредственно 
      в адресное пространство процессов, получили название файлов, отображаемых 
      в память, или, по-английски, memory mapped файлов. Надо отметить, что такое 
      отображение может быть осуществлено не только для всего файла в целом, но 
      и для его части.<br>
      <br>
      С точки зрения программиста работа с такими файлами выглядит следующим образом: 
      <br>
      <br>
      </font> 
    </p><dir> 
      <ol>
        <li> 
          <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
            Отображение файла из пространства имен в адресное пространство процесса 
            происходит в два этапа: сначала выполняется отображение в дисковое 
            пространство, а уже затем из дискового пространства в адресное. Поэтому 
            вначале файл необходимо открыть, используя обычный системный вызов 
            <a href="http://cs.mipt.ru/docs/courses/osstud/man/open.htm">open()</a>. </font> 
        
        </p></li><li> 
          <p align="justify"><font face="Times New Roman, Times, serif" size="3"> 
            Вторым этапом является отображение файла целиком или частично из дискового 
            пространства в адресное пространство процесса. Для этого используется 
            системный вызов <a href="http://cs.mipt.ru/docs/courses/osstud/man/mmap.htm">mmap()</a>. Файл после 
            этого можно и закрыть, выполнив системный вызов <a href="http://cs.mipt.ru/docs/courses/osstud/man/close.htm">close()</a>, 
            так как необходимую информацию о расположении файла на диске мы уже 
            сохранили в других структурах данных при вызове <a href="http://cs.mipt.ru/docs/courses/osstud/man/mmap.htm">mmap()</a>. 
            </font> 
        
        </p></li><li> 
          <p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
            После этого с содержимым файла можно работать, как с содержимым обычной 
            области памяти. </font> 
        
        </p></li><li> 
          <p align="justify"><font face="Times New Roman, Times, serif" size="3"> 
            По окончании работы с содержимым файла, необходимо освободить дополнительно 
            выделенную процессу область памяти, предварительно синхронизировав 
            содержимое файла на диске с содержимым этой области (если , конечно, 
            необходимо). Эти действия выполняет системный вызов <a href="http://cs.mipt.ru/docs/courses/osstud/man/munmap.htm">munmap()</a>. 
            </font> 
        
      </p></li></ol>
    </dir>
    <font face="Times New Roman, Times, serif" size="3">&nbsp; <br>
    </font> </li>
  <li> 
    <p align="justify"> <font color="#ff0000" face="Times New Roman, Times, serif" size="3"><b> 
      <a name="s1113"></a> Анализ, компиляция и прогон программы для создания 
      memory mapped файла и записи его содержимого.</b></font> <br>
      <br>
    </p><p align="justify"> <font face="Times New Roman, Times, serif" size="3"> Для 
      закрепления изложенного в предыдущем разделе давайте рассмотрим пример <a href="http://cs.mipt.ru/docs/courses/osstud/11/stud/11-1c.htm">программы</a>, 
      находящейся в файле /ftp/pub/sem11-12/11-1.c. Эта программа создает файл, 
      отображает его в адресное пространство процесса и заносит в него информацию 
      с помощью обычных операций языка С.<b> <img src="sem11-12_files/znak.gif" alt="Nota bene" align="left" border="0" hspace="10" vspace="8"> 
      Обратите внимание на необходимость увеличения размера файла перед его отображением. 
      Созданный файл имеет нулевой размер и если его с этим размером отобразить 
      в память, то мы сможем записать в него или прочитать из него не более 0 
      байт, т.е. ничего. Для увеличения размера файла использован системный вызов 
      <a href="http://cs.mipt.ru/docs/courses/osstud/man/ftruncat.htm">ftruncate()</a>, хотя это можно было бы 
      сделать и любым другим способом.</b> При отображении файла мы вынуждены 
      разрешить в нем и запись, и чтение, хотя реально совершаем только запись. 
      Это сделано, чтобы избежать ошибки в операционной системе Linux, связанной 
      с использованием 486-х и 586-х процессоров. Такой список разрешенных операций 
      однозначно требует, чтобы при открытии файла системным вызовом <a href="http://cs.mipt.ru/docs/courses/osstud/man/open.htm">open()</a> 
      файл также открывался и на запись, и на чтение. Поскольку информацию мы 
      желаем сохранить на диске, при отображении использовано значение флагов 
      <b> <font color="#008000">MAP_SHARED</font></b>. Откомпилируйте эту программу 
      и запустите ее.</font> <br>
      &nbsp; <br>
  
  </p></li><li> 
    <p align="justify"> <font color="#ff0000" face="Times New Roman, Times, serif" size="3"><b> 
      <a name="s1114"></a> Изменение предыдущей программы для чтения из файла, 
      используя его отображение в память.</b></font> <br>
      <br>
    </p><p align="justify"> <font face="Times New Roman, Times, serif" size="3"> 
      Модифицируйте программу из предыдущего <a href="http://cs.mipt.ru/docs/courses/osstud/11/stud/11-1c.htm">примера</a> 
      так, чтобы она отображала файл, записанный этой программой, в память и считала 
      сумму квадратов чисел от 1 до 100000, которые уже находятся в этом файле. 
      <br>
      <br>
      </font> <font face="Times New Roman, Times, serif" size="2"><b><u>Задача 
      повышенной сложности:</u></b> напишите две программы, использующие memory 
      mapped файл для обмена информацией при одновременной работе, подобно тому, 
      как они могли бы использовать разделяемую память. </font> <br>
  
</p></li></ol>	
<p align="center"><a href="http://cs.mipt.ru/docs/courses/osstud/exams/kr1h.htm"> Предыдущий семинар</a> | <a href="http://cs.mipt.ru/docs/courses/osstud/os.html">Программа курса</a> | 
 <a href="http://cs.mipt.ru/docs/courses/osstud/13/prep/sem13-14.htm"> Следующий семинар</a></p>
</body></html>