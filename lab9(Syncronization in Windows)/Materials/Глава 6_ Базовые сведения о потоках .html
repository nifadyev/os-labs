<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0059)http://wm-help.net/books-online/book/59464/59464-25.html -->
<HTML><HEAD><META content="IE=5.0000" http-equiv="X-UA-Compatible">
 
<META http-equiv="Content-Type" content="text/html; charset=windows-1251"> 
<META name="robots" content="index, follow">
<LINK href="Глава%206_%20Базовые%20сведения%20о%20потоках%20_files/style.css" 
rel="StyleSheet" type="text/css"> <TITLE>Глава 6. Базовые сведения о потоках 
&lt; Джеффри РИХТЕР "Windows&nbsp;для&nbsp;профессионалов" &lt; C++/C#/C &lt; 
Электронная библиотека</TITLE>
<META name="GENERATOR" content="MSHTML 11.00.9600.17041"></HEAD> 
<BODY leftmargin="1" marginheight="1" marginwidth="1"><!-- srv21439 --> <A name="top"></A> 

       
      <P><B><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="3"><A name="h6"></A>ГЛАВА 6 Базовые сведения о потоках 
      </FONT></B></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Тема, связанная с потоками, очень важна, потому что в любом 
      процессе должен быть хотя бы  один поток В этой паве концепции потоков 
      будут рассмотрены гopaз до подробнее В  частности, я объясню, в чем 
      разница между процессами и потоками и для чего они  предназначены Также я 
      расскажу о том, как система использует объек ты ядра  "поток» для 
      управления потоками Подобно процессам, потоки обладают оп  ределенными 
      свойствами, поэтому мы поговорим о функциях, позволяющих обра щаться  к 
      этим свойствам и при необходимости модифицировать их Кроме того, Вы 
      узнаете о  функциях, предназначенных для создания (порождения) 
      дополнительных потоков в  системе </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">В 
      главе 4 я  говорил, что процесс фактически состоит из двух компонентов 
      объекта ядра  "процесс" и адресного пространства так вот, любой поток тожс 
      состоит из двух  компонентов. </FONT></P>
      <UL>
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">объекта   ядра, через который операционная система управляет 
        потоком Там же хранится   статистическая информация о потоке; </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">стека   потока, который содержит параметры всех функций и 
        локальные пере менные,    необходимые потоку для выполнения кода (О том, 
        как система управ ляет стеком   потока, я расскажу в главе 16) 
        </FONT></LI></UL>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">В 
      той же  главе 4 я упомянул, что процессы инертны Процесс ничего не исполня 
      ет, он просто  служит контейнером потоков Потоки всегда создаются в 
      контексте какого-либо  процесса, и вся их жизнь проходит только в его 
      границах На практике это  означает, что потоки исполняют код и 
      манипулируют данными в адресном про  странстве процесса Поэтому, если два 
      и более потоков выполняется в контексте од  ного процесса, все они делят 
      одно адресное пространство Потоки могут исполнять  один и тот же код и 
      манипулировать одними и теми же данными, а также совместно  использовать 
      описатели объектов ядра, поскольку таблица описателей создается нс  в 
      отдельных потоках, а в процессах </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">Как 
      видите,  процессы используют куда больше системных ресурсов, чем потоки 
      Причина кроется в  адресном пространстве Создание виртуального адресного 
      про странства для процесса  требует значительных системных ресурсов При 
      этом ведет ся масса всяческой  статистики, па что уходит немало памяти В 
      адресное простран ство загружаются  EXE- и DLL-файлы, а значит, нужны 
      файловые ресурсы С другой стороны, потоку  требуются лишь соответствующий 
      объект ядра и стек, объем стати стических  сведений о потоке невелик и 
      много памяти не занимает </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">Так 
      как  потоки расходуют существенно меньше ресурсов, чем процессы, старай 
      тесь решать  свои задачи за счет использования дополнительных потоков и 
      избегайте создания  новых процессов Только не принимайте этот совет за 
      жесткое правило — многие  проекты как paз лучше реализовать на основе 
      множества процессов Нужно просто  помнить об издержках и соразмерять цель 
      и средства </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Прежде чем мы  углубимся в скучные, но крайне важные концепции, 
      давайте обсу дим, как правильно  пользоваться потоками, разрабатывая 
      архитектуру приложения. </FONT></P>
      <H2><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="2"><B><A name="h6t1"></A>В каких случаях потоки создаются</B> 
      </FONT></H2>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Поток  (thread) определяет последовательность исполнения кода в 
      процессе. При  инициализации процесса система всегда создает первичный 
      поток Начинаясь со  стартовою кодц из библиотеки С/С++, который в свою 
      очередь вызывает входную  функцию <I>(WinMain, wWinMain, main </I>или 
      <I>wmain) </I>из Вашей программы, он  живет до того момента, когда входная 
      функция возвращает управление стартовому  коду и тот вызывает функцию 
      <I>ExitProcess. </I>Большинство приложений обходится  единственным, 
      первичным потоком. Однако процессы могут создавать дополнительные  потоки, 
      что позволяет им эффективнее выполнять свою работу </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">У 
      каждого  компьютера есть чрезвычайно мощный ресурс — центральный процес 
      сор. И нет  абсолютно никаких причин тому, чтобы этот процессор простаивал 
      (не считая  экономии электроэнергии) Чтобы процессор всегда был при деле, 
      Вы нагру жаете его  самыми разнообразными задачами Вот несколько примеров 
      </FONT></P>
      <UL>
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Вы   активизируете службу индексации данных (content indexing 
        service) Win dows   2000. Она создает поток с низким приоритетом, 
        который, периодически   пробуждаясь, индексирует содержимое файлов на 
        дисковых устройствах Ва шего   компьютера. Чтобы найти какой-либо файл, 
        Вы открываете окно Search Results   (щелкнув кнопку Start и выбрав из 
        меню Search команду For Files Or Folders) и   вводите в поле Containing 
        Text нужные критерии поиска. После это го начинается   поиск по индексу, 
        и на экране появляется список файлов, удов летворяющих этим   критериям. 
        Служба индексации данных значительно уве личивает скорость поиска,    
        так как при ее использовании больше не требуется открывать, сканировать 
        и   закрывать каждый файл на диске </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Вы   запускаете программу для дефрагмептации дисков, 
        поставляемую с Win dows 2000.    Обычно утилиты такого рода предлагают 
        массу настроек для адми нистрирования, в   которых средний пользователь 
        совершенно не разбирает ся, — например, когда и   как часто проводить 
        дефрагментацию Благодаря по токам с более низким   приоритетом Вы можете 
        пользоваться этой программой в фоновом режиме и   дефрагментировать 
        диски в те моменты, когда других дел у системы нет. </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Нетрудно   представить будущую версию компилятора, способную 
        автоматичес ки компилировать   файлы исходного кода в паузах, 
        возникающих при наборе текста программы. Тогда   предупреждения и 
        сообщения об ошибках появлялись бы практически в режиме   реального 
        времени, и Вы тут же видели бы, в чем Вы ошиблись Самое интересное,    
        что Microsoft Visual Studio в какой-то мере уже умеет это делать, — 
        обратите   внимание на секцию ClassView в Workspace </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Электронные таблицы пересчитывают данные в фоновом режиме 
        </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Текстовые   процессоры разбивают текст на страницы, проверяют 
        его на орфог рафические и   грамматические ошибки, а также печатают в 
        фоновом режиме. </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Файлы   можно копировать на другие носители тоже в фоновом 
        режиме </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Web-браузеры способны взаимодействовать с серверами в фоновом 
        рсжимс   Благодаря этому пользователь может перейти на другой Web-узел, 
        не дожида ясь,    когда будут получены результаты с текущего Web-узла. 
        </FONT></LI></UL>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Одна важная  вещь, на которую Вы должны были обратить внимание во 
      всех этих примерах,  заключается в том, что поддержка многопоточности 
      позволяет упростить  пользовательский интерфейс приложения Если компилятор 
      ведет сборку Вашей про  граммы в те моменты, когда Вы делаете паузы в 
      наборе ее текста, отпадает  необходи мость в командах меню Build. То же 
      самое относится к командам Check  Spelling и Check Grammar в текстовых 
      процессорах. </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">В 
      примере с  Web-браузером выделение ввода-вывода (сетевого, файлового или 
      какого-то другого)  в отдельный поток обеспечивает "отзывчивость» 
      пользовательс кого интерфейса  приложения даже при интенсивной передаче 
      данных, Вообразите приложение, которое  сортирует записи в базе данных, 
      печатает документ или копи рует файлы Возложив  любую из этих задач, так 
      или иначе связанных с вводом-выво дом, на отдельный  поток, пользователь 
      может по-прежнему работать с интерфейсом приложения и при  необходимости 
      отменить операцию, выполняемую в фоновом режиме. </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Многопоточное  приложение легче масштабируется Как Вы увидите в 
      следующей главе, каждый поток  можно закрепить за определенным 
      процессором. Так что, если в Вашем компьютере  имеется два процессора, а в 
      приложении — два потока, оба процес сора будут при  деле. И фактически Вы 
      сможете выполнять две задачи одновременно. </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">В 
      каждом  процессе есть хотя бы один поток, Даже не делая ничего особенного 
      в приложении,  Вы уже выигрываете только от того, что оно выполняется в 
      многопо точной  операционной системе. Например, Вы можете собирать 
      программу и одно временно  пользоваться текстовым процессором (довольно 
      часто я так и работаю) Если в  компьютере установлено два процессора, то 
      сборка выполняется на одном из них, а  документ обрабатывается на другом. 
      Иначе говоря, какого-либо падения про  изводительности не наблюдается. И 
      кроме того, если компилятор из-за той или иной  ошибки входит в 
      бесконечный цикл, на остальных процессах это никак не отражает  ся. 
      (Конечно, о программах для MS-DOS и 16-разрядной Windows речь не идет,)  
      </FONT></P>
      <H2><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="2"><B><A name="h6t2"></A>И в каких случаях потоки не создаются</B> 
      </FONT></H2>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">До 
      сих пор я  пел одни дифирамбы многопоточным приложениям Но, несмотря на 
      все преимущества, у  них есль и свои недостатки Некоторые разработчики 
      почему-то считают, будто любую  проблему можно решить, разбив программу на 
      отдельные по токи. Трудно совершить  большую ошибку! </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Потоки - вещь  невероятно полезная, когда ими пользуются с умом. 
      Увы, решая старые проблемы,  можно создать себе новые. Допустим, Вы 
      разрабатываете тексто вый процессор и  хотите выделить функциональный 
      блок, отвечающий за распечат ку, в отдельный  поток. Идея вроде неплоха: 
      пользователь, отправив документ на рас печатку, может  сразу вернуться к 
      редактированию Но задумайтесь вот над чем. зна чит, информация  в 
      документе может быть изменена <I>при </I>распечатке документа? Как видите, 
       теперь перед Вами совершенно новая проблема, с которой прежде сталкивать 
      ся не  приходилось. Тут-то и подумаешь, а стоит ли выделять печать в 
      огдельный по ток,  зачем искать лишних приключений? Но давайте разрешим 
      при распечатке редак  тирование любых документов, кроме того, который 
      печатается в данный момент. Или  так. скопируем документ во временный файл 
      и отправим па печать именно его, а  пользователь пусть редактирует 
      оригинал в свое удовольствие. Когда распечатка  вре менного файла 
      закончится, мы его удалим — вот и все. </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">Еще 
      одно  узкое место, где неправильное применение потоков может привести к 
      </FONT><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">появлению проблем, —  разработка пользовательского интерфейса в 
      приложении В </FONT><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">подавляющем  большинстве программ все компоненты 
      пользовательского интерфей </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">ca 
      (окна)  обрабатываются одним и тсм жс потоком. И дочерние окна любого окна 
      определенно  должен создавать только один поток. Создание разных окон в 
      разных потоках иногда  имеет смысл, но такие случаи действительно редки. 
      </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Обычно в  приложении существует один поток, отвечающий за 
      поддержку пользо вательского  интерфейса, — он создает все окна и содержит 
      цикл <I>GetMessage </I>Любые другие  потоки в процессе являются рабочими 
      (т. e. отвечают за вычисления, ввод вывод и  другие операции) и не создают 
      никаких окон, Поток пользовательского ин терфейса,  как правило, имеет 
      более высокий приоритет, чем рабочие потоки, — это нужно для  того, чтобы 
      он всегда быстро реагировал на действия пользователя. </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Несколько  потоков пользовательского интерфейса в одном процессе 
      можно об наружить в таких  приложениях, как Windows Explorcr Он создаст 
      отдельный поток для каждого окна  папки. Это позволяет копировать файлы из 
      одной папки в другую и попутно  просматривать содержимое еще какой-то 
      папки. Кроме того, если какая-то ошибка в  Explorer приводит к краху 
      одного из cro потоков, прочие потоки остаются  работоспособны, и Вы можете 
      пользоваться соответствующими окнами, пока не сде  лаете что-нибудь такое, 
      из-за чего рухнут и они. (Подробнее о потоках и пользова  тельском 
      интерфейсе см. главы 26 и 27.) </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">В 
      общем,  мораль этого вступления такова: многопоточность следует 
      использовать разумно. Не  создавайте несколько потоков только потому, что 
      это возможно. Многие полезные и  мощные программы по-прежнему строятся на 
      основе одного первично го потока,  принадлежащего процессу </FONT></P>
      <H2><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="2"><B><A name="h6t3"></A>Ваша первая функция потока</B> </FONT></H2>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Каждый поток  начинает выполнение с некоей входной функции. В 
      первичном пото ке таковой  является <I>main, wmain, WinMain </I>или 
      <I>wWinMain. </I>Если Вы хотите создать  вто ричный поток, в нем тоже 
      должна быть входная функция, которая выглядит  пример но так </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">DWORD WINAPI   ThreadFunc(PVOID pvPararn) <BR>{ <BR>DWORD 
        rtwResult = 0; </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">return(dwResult); <BR>} </FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Функция  потока может выполнять любые задачи. Рано или поздно она 
      закончит свою работу и  вернет управление. В этот момент Ваш поток 
      остановится, память, от веденная под  его стек, будет освобождена, а 
      счетчик пользователей его объекта ядра "поток"  уменьшится на 1. Когда 
      счетчик обнулится, этот объект ядра будет разрушен Но,  как и объект ядра 
      "процесс", он может жить гораздо дольше, чем сопоставленный с  ним поток. 
      </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">А 
      теперь  поговорим о самых важных вещах, касающихся функций потоков 
      </FONT></P>
      <UL>
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">В отличие   от входной функции первичного потока, у которой 
        должно быть одно из четырех   имен: <I>main, wmain, WinMain </I>или 
        <I>wWinMain, — </I>функцию пото ка можно   назвать как угодно. Однако, 
        если в программе несколько функций потоков, Вы   должны присвоить им 
        разные имена, иначе компилятор или компоновщик решит, что   Вы создаете 
        несколько реализаций единственной функции. </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Поскольку   входным функциям первичного потока передаются 
        строковые пара метры, они   существуют в ANSI- и Unicode-версиях: 
        <I>main - wmain </I>и <I>WinMain —</I>   </FONT></LI></UL>
      <BLOCKQUOTE>
        <P><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3"><I>wWinA4ain. </I>Но функциям потоков передается единственный 
        параметр,    смысл которого определяется Вами, а не операционной 
        системой Поэтому здесь нет   проблем с 
ANSI/Unicode</FONT></P></BLOCKQUOTE>
      <UL>
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Функция   потока должна возвращать значение, которое будет 
        использоваться как код   завершения потока. Здесь полная аналогия с 
        библиотекой С/С++: код завершения   первичного потока становится кодом 
        завершения процесса. </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Функции   потоков (да и все Ваши функции) должны по мере 
        возможности об ходиться своими   параметрами и локальными переменными. 
        Так как к стати ческой или глобальной   переменной могут одновременно 
        обратиться несколь ко потоков, есть риск   повредить ее содержимое. 
        Однако параметры и локаль ные переменные создаются в   стеке потока, 
        поэтому они в гораздо меньшей степени подвержены влиянию другого   
        потока. </FONT></LI></UL>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">Вот 
      Вы и  узнали, как должна быть реализована функция потока Теперь рассмот 
      рим, как  заставить операционную систему создать поток, который выполнит 
      эту фун кцию.  </FONT></P>
      <H2><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="2"><B><A name="h6t4"></A>Функция CreateThread</B> </FONT></H2>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">Мы 
      уже  говорили, как при вызове функции <I>CreateProcess </I>появляется на 
      свет первич  ный поток процесса. Если Вы хотите создать дополнительные 
      потоки, нужно вызывать  из первичного потока функцию <I>CreateThread:</I> 
      </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">HANDlF   CreateThread( <BR>PSECURITY_ATTRIBUTES psa, DWORD   
        cbStack,<BR>PTHREAD_START_ROUTINE pfnStartAddr, PVOID pvParam, DWORD   
        tdwCreate, PDWORD pdwThreadID);</FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">При 
      каждом  вызове этой функции система создает объект ядра "поток» Это не сам 
      поток, а  компактная структура данных, которая используется операционной 
      систе мой для  управления потоком и хранит счатистическую информацию о 
      потоке. Так что объект  ядра "поток" — полный аналог объекта ядра 
      "процесс". </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Система  выделяет память под стек потока из адресного 
      пространства процесса. Новый поток  выполняется в контексте того же 
      процесса, что и родительский поток. Поэтому он  получает доступ ко всем 
      описателям объектов ядра, всей памяти и стекам всех  потоков в процессе. 
      За счет этого потоки в рамках одного процесса могут легко 
       взаимодействовшьдруг с другом.</FONT><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3"> </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#006600" face="Arial, Helvetica, sans-serif" 
        size="2"><FONT color="#990000">NOTE:</FONT> <BR><I>CreateTbread - 
        </I>это Windows-функция,    создающая поток. Но никогда не вы зывайте 
        ее, если Вы пишете код на С/С++    Вместо нее Вы должны использо вать 
        функцию <I>beginthreadex </I>из библиотеки    Visual С++. (Если Вы 
        работаете с другим компилятором, он должен поддерживать   свой 
        эквивалент функции <I>CreateThread.</I>) Что именно делает    
        _<I>beginthreadex </I>и почему это так важно, я объясню потом.    
        </FONT></P><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3"></FONT></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">О'кэй, общее  представление о функции <I>CreateThread </I>Вы 
      получили. Давайте рас смотрим все  ее параметры. </FONT></P>
      <H2><I><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="2"><A name="h6t4p1"></A>Параметр psa </FONT></I></H2>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Параметр  <I>psa </I>является указателем на структуру 
      SECURITY_ATTRIBUTES Если Вы хо тите,  чтобы объектуядра "поток" были 
      присвоены атрибуты защиты по умолчанию (что чаще  всего и бывает), 
      передайте в этом параметре NULL A чтобы дочерние про цессы  смогли 
      наследовать описатель этого объекта, определите структуру SECURI 
       TY_ATTRIBUTES и инициализируйте ее элемент <I>hlnherttHandle 
      </I>значением TRUE  (см. главу 3) </FONT></P>
      <H2><I><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="2"><A name="h6t4p2"></A>Параметр cbStack </FONT></I></H2>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Этот параметр  определяет, какую часть адресного пространства 
      поток сможет исполь зовать под  свой стек. Каждому потоку выделяется 
      отдельный стек Функция <I>Create Process,  </I>запуская приложение, 
      вызывает <I>CreateThread, </I>и та инициализирует  первич ный поток 
      процесса При этом <I>CreateProcess </I>заносит в параметр  <I>cbStack 
      </I>значение, хранящееся в самом исполняемом файле Управлять этим 
       значением позволяет ключ /STACK компоновщика: </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#9900ff" face="Courier New, Courier, mono" 
        size="2">/STACK.[reserve] [,commit] </FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Аргумент  <I>reserve </I>определяет объем адресного пространства, 
      который система должна  зарезервировать под стек потока (по умолчанию — 1 
      Мб). Аргумент <I>commit  </I>задает объем физической памяти, который 
      изначально передается области,  зарезер вированной под стек (по умолчанию 
      — 1 страница). По мере исполнения кода  в по токе Вам, весьма вероятно, 
      понадобится отвести под стек больше одной  страницы памяти. При 
      переполнении стека возникнет исключение (О стеке потока и  исключе ниях, 
      связанных с его переполнением, см. главу 16, а об общих принципах  обработ 
      ки исключений — главу 23.) Перехватив это исключение, система передаст 
       зарезер вированному пространству еще одну страницу (или столько, сколько 
      указано  в аргу менте <I>commit) </I>Такой механизм позволяет динамически 
      увеличивать  размер стека лишь по необходимости. </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Если Вы,  обращаясь к <I>CreateThread, </I>передаете в параметре 
      <I>cbStack </I>ненулевое  зна чение, функция резервирует всю указанную 
      Вами память. Ее объем определяется  либо значением параметра <I>cbStack, 
      </I>либо значением, заданным в ключе /STACK  компонов щика (выбирается 
      большее из них). Но передается стеку лишь тот объем  памяти, ко торый 
      соответствует значению в <I>cbStack </I>Если же Вы передаете в  параметре 
      <I>cbStack </I>нулевое значение, <I>CreateThread </I>создает стск для 
       нового потока, используя информа цию, встроенную компоновщиком в ЕХЕ-файл 
       </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Значение  аргумента <I>reserve </I>устанавливает верхний предел 
      для стека, и это огра  ничение позволяет прекращать деятельность функций с 
      бесконечной рекурсией. До  пустим, Вы пишете функцию, которая рекурсивно 
      вызывает сама себя Предположим  также, что в функции есть "жучок», 
      приводящий к бесконечной рекурсии. Всякий  раз, когда функция вызывает 
      сама себя, в стске создается новый стековый фрейм.  Если бы система не 
      позволяла ограничивать максимальный размер стека, рекурсивная  функ ция 
      так и вызывала бы сама себя до бесконечности, а стек поглотил бы все 
       адресное пространство процесса. Задавая же определенный предел, Вы, 
      во-первых,  предотвра щаете разрастание стека до гигантских объемов и, 
      во-вторых, гораздо  быстрее узна ете о наличии ошибки в своей программе. 
      (Программа-пример Summation  в главе 16 продемонстрирует, как 
      перехватывать и обрабатывать переполнение стека  в прило жениях ) 
      </FONT></P>
      <H2><I><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="2"><A name="h6t4p3"></A>Параметры pfnStartAddr и pvParam 
      </FONT></I></H2>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Параметр  <I>pfnStartAddr </I>определяет адрес функции потока, с 
      которой должен будет  начять работу создаваемый поток, а параметр 
      <I>pvParam </I>идентичен  параметру<I> рvРаrат </I>функции потока. 
      <I>CreateTbread </I>лишь<I></I>передает этот параметр по эстафете той функ 
      ции, с которой начинается  выполнение создаваемого потока. Таким образом, 
      данный параметр позволяет  передавать функции потока какое-либо 
      инициализирующее зна чение. Оно может быть  или просто числовым значением, 
      или указателем на структу ру данных с  дополнительной информацией. 
      </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Вполне  допустимо и даже полезно создавать несколько потоков, у 
      которых в ка честве  входной точки используется адрес одной и той же 
      функции. Например, мож но  реализовать Web-сервер, который обрабатывает 
      каждый клиентский запрос в от  дельном потоке. При создании каждому потоку 
      передается свое значение  <I>рvParam.</I> </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Учтите, что  Windows — операционная система с вытесняющей 
      многозадачностью, а следовательно,  новый поток и поток, вызвавший 
      <I>CreateThread, </I>могут выполняться  одновременно В связи с этим 
      возможны проблемы Остерегайтесь, например, такого  кода. </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">DWORD WINAPI   FirstThread(PVOID pvParam) <BR>{ <BR>// 
        инициализируем переменную, которая   содержится в стеке </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">int 
        x = 0;    <BR>DWORD dwThreadID; </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">// 
        создаем   новый поток <BR>HANDLE hThread = CreateThread(NULL, 0, 
        SecondThread, (PVOID)   &amp;x, 0, &amp;dwThreadId); </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">// 
        мы больше   не слылаемся на новый поток, <BR>// поэтому закрываем свой 
        описатель этого   потока <BR>CloseHandle(hThread); </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">// 
        Наш поток   закончил работу. <BR>// ОШИБКА, его стек будет разрушен, но 
        SecondThread //    может попытаться обратиться к нему return(0); <BR>} 
        </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">DWORD WINAPI   SecondThread(PVOID pvParam) { <BR>// здесь 
        выполняется какая-то длительная   обработка <BR>// Пытаемся обратиться к 
        переменной в стеке FirstThread,<BR>//    ПРИМЕЧАНИЕ- это может привести 
        к ошибке общей защиты <BR>// нарушению   доступа<SUP></SUP>* ((int *) 
        pvParam) = 5; </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">relurn(0);    <BR>} </FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">Не 
      исключено,  что в приведенном коде <I>FirstThread </I>закончит свою работу 
      до того, как  <I>SecondThread </I>присвоит значение <I>5 </I>переменной 
      <I>x </I>из  <I>FirstThread. </I>Если так и будет, <I>SecondThread </I>не 
      узнает, что  <I>FirstThread </I>больше не существует, и попытается 
      изменить содержимое  какого-то участка памяти с недействительным теперь 
      адресом. Это не избежно  вызовет нарушение доступа: стек первого потока 
      уничтожен по завершении  </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3"><I>FirstThread. </I>Что же делать? Можно объявить <I>x 
      </I>статической  переменной, и компиля тор отведет память для хранения 
      переменной <I>x </I>не в  стеке, а в разделе данных прило жения 
      (application's data section). Ho тогда  функция станет нереентерабельной. 
      Ина че говоря, в этом случае Вы не смогли бы  создачь два потока, 
      выполняющих одну и ту же функцию, так как оба потока  совместно 
      использовали бы статическую перемен ную Другое решение этой проблемы  (и 
      его более сложные варианты) базируется па методах синхронизации потоков, 
      речь  о которых поЙдет в главах 8, 9 и 10. </FONT></P>
      <H2><I><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="2"><A name="h6t4p4"></A>Параметр fdwCreate </FONT></I></H2>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Этот параметр  определяет дополнительные флаги, управляющие 
      созданием потока. Он принимает одно  из двух значений. 0 (исполнение 
      потока начинается немедлен но) или  CREATE_SlJSPENDED. В последнем случае 
      система создает поток, инициали зирует его  и приостанавливает до 
      последующих указаний. </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Флаг  CREATE_SUSPENDED позволяет программе изменить какие-либо 
      свойства потока перед  тем, как он начнет выполнять код Правда, 
      необходимость в этом воз никает  довольно редко Одно из применений этого 
      флага демонстрирует програм мa - пример  JobLab из главы 5 </FONT></P>
      <H2><I><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="2"><A name="h6t4p5"></A>Параметр pdwThreadlD </FONT></I></H2>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Последний  параметр функции <I>CreateTbread — </I>это адрес 
      переменной типа DWORD, в  которой функция возвращает идентификатор, 
      приписанный системой новому пото ку.  (Идентификаторы процессов и но'юков 
      рассматривались в главе 4.)</FONT><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3"> </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#006600" face="Arial, Helvetica, sans-serif" 
        size="2"><FONT color="#990000">NOTE:</FONT> <BR>В Windows 2000 и Windows 
        NT 4 в этом параметре   можно передавать NULL (обычно так и делается). 
        Тем самым Вы сообщаете функции,    что Вас не инте ресует идентификатор 
        потока Ilo в Windows 95/98 это приведет к   ошибке, так как функция 
        попытается записать идентификатор потока no нулевому   адресу, что 
        недопустимо. И поток не будет создан. </FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Такое  несоответствие между операционными системами может создать 
      разработчикам  приложений массу проблем, Допустим, Вы пишете и тестируе те 
      программу в Windows  2000 (которая создает поток, даже если Вы передаете 
      NULL в <I>pdwThreadID)  </I>Но вот Вы запускаете приложение в Windows 98, 
      и фун кция <I>CreateThread,  </I>естественно, дает ошибку. Вывод один: 
      тщательно тестируй те свос приложение  во всех операционных системах, в 
      которых оно будет работать </FONT><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3"></FONT></P>
      <H2><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="2"><B><A name="h6t5"></A>Завершение потока</B> </FONT></H2>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Поток можно  завершить четырьмя способами: </FONT></P>
      <UL>
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">функция   потока возвращает управление (рекомендуемый способ), 
        </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">поток   самоуничтожяется вызовом функции <I>ExitThread 
        </I>(нежелательный способ);    </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">один из   потоков данного или стороннего процесса вызывает 
        функцию <I>Termi nateThread    </I>(нежелательный способ); </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">завершается процесс, содержащий данный поток (тоже 
        нежелательно).    </FONT></LI></UL>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">В 
      этом  разделе мы обсудим перечисленные способы завершения потока, а также 
      рассмотрим,  что на самом деле происходит в момент его окончания. 
      </FONT></P>
      <H2><I><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="2"><A name="h6t5p1"></A>Возврат управления функцией потока 
      </FONT></I></H2>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Функцию  потока следует проектировать так, чтобы поток завершался 
      только после того, как  она возвращает управление. Это единственный 
      способ, гарантирующий кор ректную  очистку всех ресурсов, принадлежавших 
      Вашему потоку. При этом: </FONT></P>
      <UL>
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">любые   С++-объекты, созданные данным потоком, уничтожаются 
        соответству ющими   деструкторами; </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">система   корректно освобождает память, которую занимал стек 
        потока; </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">система   устанавливает код завершения данного потока 
        (поддерживаемый объ ектом ядра    "поток») — его и возвращает Ваша 
        функция потока; </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">счетчик   пользователей данного объекта ядра "поток" 
        уменьшается на 1 </FONT></LI></UL>
      <H2><I><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="2"><A name="h6t5p2"></A>Функция ExitThread </FONT></I></H2>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Поток можно  завершить принудительно, вызвав: </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">VOID 
          ExitThread(DWORD dwExitCоde);</FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">При 
      этом  освобождаются все ресурсы операционной системы, выделенные дан ному 
      потоку, но  C/C++ - pеcypcы (например, объекты, созданные из С++-классов) 
      не очищаются  Именно поэтому лучше возвращать управление из функции 
      потока, чем самому  вызывать функцию <I>ExitThread. </I>(Подробнее на эту 
      тему см. раздел "Функция  ExitProcess» в главе 4.) </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">В 
      параметр  <I>dwExitCode </I>Вы помещаете значение, которое система 
      рассматривает как код  завершения потока. Возвращаемого значения у этой 
      функции нет, потому что после  ее вызова поток перестает 
      существовать.</FONT><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3"> </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#006600" face="Arial, Helvetica, sans-serif" 
        size="2"><FONT color="#990000">NOTE:</FONT> <BR><I>ExitThread — </I>это 
        Windows-функция,    которая уничтожает поток. Но никогда не вы зывайте 
        ее, если Вы пишете код на   С/С++ Вместо нее Вы должны использовать 
        функцию <I>_endthreadex </I>из   библиотеки Visual С++ (Если Вы 
        работаете с другим компилятором, он должен   поддерживать свой 
        эквивалент функции <I>ExitThread) </I>Что именно делает    
        <I>_endthreadex </I>и почему это так важно, и объясню потом. 
        </FONT></P><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3"></FONT></BLOCKQUOTE>
      <H2><I><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="2"><A name="h6t5p3"></A>Функция TerminateThread </FONT></I></H2>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Вызов этой  функции также завершает поток: </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">BOOL 
          TerminateThread( HANDLE hThread, DWORD 
      dwExitCode);</FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">В 
      отличие от  <I>ExitThread, </I>которая уничтожает только вызывающий поток, 
      эта фун кция  завершает поток, указанный в параметре <I>hThread. </I>В 
      параметр <I>dwExitCode  </I>Вы помещаете значение, которое система 
      рассматривает как код завершения  потока. После того как поток будет 
      уничтожен, счетчик пользователей его объекта  ядра "по ток» уменьшится на 
      1</FONT><FONT color="#000000" face="Times New Roman, Times, serif" size="3"> 
      </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#006600" face="Arial, Helvetica, sans-serif" 
        size="2"><FONT color="#990000">NOTE:</FONT> <BR><I>TerminateThread — 
        </I>функция ясинхронная,    т, e. она сообщает системе, что Вы хотите 
        завершить поток, но к тому времени,    когда она вернет управление, 
        поток может быть еще не уничтожен. Так что, если   Вам нужно точно знать 
        момент завершения потока, используйте    <I>WaitForSingleObject </I>(см. 
        главу 9) или аналогичную функцию, передав ей   описатель этого потока 
        </FONT></P><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3"></FONT></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Корректно  написанное приложение не должно вызывать эту функцию, 
      поскольку поток не  получает никакого уведомления о завершении; из-за 
      этого он не может вы полнить  должную очистку ресурсов.</FONT><FONT color="#000000" 
      face="Times New Roman, Times, serif" size="3"> </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#006600" face="Arial, Helvetica, sans-serif" 
        size="2"><FONT color="#990000">NOTE:</FONT> <BR>Уничтожение потока при 
        вызове <I>ExitThread    </I>или возврате управления из функ ции потока 
        приводит к разрушению его   стека. Но если он завершен функцией 
        <I>TerminateThread, </I>система не   уничтожает стек, пока не завершится 
        и процесс, которому принадлежал этот поток   Так сделано потому, что 
        другие потоки могут использовать указатели,    ссылающиеся на данные в 
        стеке завершенного потока. Если бы они обратились к   несуществующему 
        стеку, произошло бы на рушение доступа </FONT></P>
        <P><FONT color="#006600" face="Arial, Helvetica, sans-serif" 
        size="2">Кроме того,    при завершении потока система уведомляет об этом 
        все DLL, подключенные к   процессу — владельцу завершенного потока. Но 
        при вызове <I>TetminateThread    </I>такого<I></I>не происходит, и 
        процесс может быть завершен некор ректно    (Подробнее на этутему см. 
        главу 20.) </FONT></P><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3"></FONT></BLOCKQUOTE>
      <H2><I><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="2"><A name="h6t5p4"></A>Если завершается процесс </FONT></I></H2>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Функции  <I>ExitProcess </I>и <I>TerminateProcess, 
      </I>рассмотренные в главе 4, тоже  завершают потоки. Единственное отличие 
      в том, что они прекращают выполнение всех  потоков, принадлежавших 
      завершенному процессу При этом гарантируется  высвобождение любых 
      выделенных процессу ресурсов, в том числе стеков потоков  Однако эти две 
      функции уничтожают потоки принудительно — так, будто для каждого  из них 
      вызы вается функция <I>TerminateThread. </I>А это означает, что очистка 
       проводится некоррект но, деструкторы С++-объектов не вызываются, данные 
      на диск  не сбрасываются и т д</FONT><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3"> </FONT></P>
      <H2><I><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="2"><A name="h6t5p5"></A>Что происходит при завершении потока 
      </FONT></I></H2>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">А 
      происходит  вот что. </FONT></P>
      <UL>
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Освобождаются все описатели User-объектов, принадлежавших 
        потоку. В Win   dows большинство объектов принадлежит процессу, 
        содержащему поток, из которого   они были созданы Сам поток владеет 
        только двумя User-объектами, окнами и   ловушками (hooks). Когда поток, 
        создавший такие объекты, заверша ется, система   уничтожает их 
        автоматически. Прочие объекты разрушаются, только когда   завершается 
        владевший ими процесс. </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Код   завершения потока меняется со STILL_ACTIVE на код, 
        переданный в функ цию    <I>ExitThread </I>или <I>TerminateTbread.</I> 
        </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Объект   ядра "поток" переводится в свободное состояние. 
        </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Если   данный поток является последним активным потоком в 
        процессе, завер шается и   сам процесс. </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Счетчик   пользователей объекта ядра "поток" уменьшается на 1. 
        </FONT></LI></UL>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">При 
       завершении потока сопоставленный с ним объект ядра "поток* не освобож 
      дается до  тех пор, пока не будут закрыты все внешние ссылки на этот 
      объект. </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Когда поток  завершился, толку от его описателя другим потокам в 
      системе в об щем немного.  Единственное, что они могут сделать, — вызвать 
      функцию <I>GetExitCode Thread,  </I>проверить, завершен ли поток, 
      идентифицируемый описателем <I>hThread, </I>и,  если да, определить его 
      код завершения. </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">BOOL 
          GetExitCodeThread( HANDLE hThread, PDWORD 
      pdwExitCode);</FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">Код 
       завершения возвращается в переменной типа DWORD, на которую указывает  
      <I>pdwExitCode </I>Если поток не завершен на момент вызова 
      <I>GetExitCodeThread,  </I>функция записывает в эту переменную 
      идентификатор STILL_ACTIVE (0x103) При  успешном вызове функция возвращает 
      TRUE К использованию описателя для  определения фак та завершения потока 
      мы еще вернемся в главе 9. </FONT></P>
      <H2><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="2"><B><A name="h6t6"></A>Кое-что о внутреннем устройстве потока</B> 
      </FONT></H2>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">Я 
      уже  объяснил Вам, как реализовать функцию потока и как заставить систему 
      создать  поток, который выполнит эту функцию. Теперь мы попробуем 
      разобраться, как сис  тема справляется с данной задачей </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">На 
      рис. 6-1  показано, что именно должна сделать система, чтобы создать и ини 
      циализировать  поток. Давайте приглядимся к этой схеме повнимательнее 
      Вызов <I>CreateThread  </I>заставляет систему создать объект ядра "поток». 
      При этом счетчику чис ла его  пользователей присваивается начальное 
      значение, равное 2. (Объект ядра "по ток"  уничтожается только после того, 
      как прекращается выполнение потока и закры  вается описатель, возвращенный 
      функцией <I>CreateThread</I>)<I></I>Также  инициализируются другие 
      свойства этого объекта счетчик числа простоев  (suspension count) получает 
      значение 1, а код завершения — значение STILL_ACTIVE  (0x103) И, наконец, 
      объект переводится в состояние "занято». </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Создав объект  ядра "поток», система выделяет стеку потока память 
      из адресного пространства  процесса и записывает в его самую верхнюю часть 
      два значения (Сте ки потоков  всегда строятся от старших адресов памяти к 
      младшим) Первое из них является  значением параметра <I>pvParam, 
      </I>переданного Вами функции <I>CreateThread,  </I>а второе — это 
      содержимое параметра <I>pfnStartAddr,</I> который Вы тоже  передаете в 
      <I>Create Thread</I> </FONT></P>
      <P align="center"><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3"><IMG width="634" height="278" alt="h5-5.jpg" src="Глава%206_%20Базовые%20сведения%20о%20потоках%20_files/h5-5.jpg"> 
      </FONT></P>
      <P align="center"><FONT color="#009900" face="Arial, Helvetica, sans-serif" 
      size="2">Рис. 6-1. Так создается и инициализируется поток </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">У 
      каждого  потока собсвенный набор регистров процессора, называемый 
      <I>контек стом  </I>потока. Контекст отражает состояние регистров 
      процессора на момент после  днего исполнения потока и записывается в 
      структуру CONTEXT (она определена в  заголовочном файле WinNT.h). Эта 
      структура содержится в объекте ядра "поток»  </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Указатель  команд (IP) и указатель стека (SP) — два самых важных 
      регистра в кон тексте  потока. Вспомните: потоки выполняются в контексте 
      процесса. Соответствен но эти  регистры всегда указывают на адреса памяти 
      в адресном пространстве про цесса.  Когда система инициализирует объект 
      ядра "поток", указателю стека в струк туре  CONTEXT присваивается тот 
      адрес, по которому в стек потока было записано зна  чение <I>pfnStartAddr, 
      </I>а указателю команд — адрес недокументированной (и  неэкспор тируемой) 
      функции <I>BaseThreadStart. </I>Эта функция содержится в  модуле 
      Kernel32.dll, где, кстати, реализована и функция <I>CreateTbread.</I> 
      </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">Вот 
      главное,  что делает <I>BaseThreadStart:</I> </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">VOID 
          BaseThreadStart(PTHREAD_START_ROUTINE pfnStartAddr, PVOID pvParam)    
        <BR>{</FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">__try <BR>{    <BR>ExitThread((pfnStartAddr)(pvParam)); <BR>} 
        </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">_except(UnhandledExceptionFilter(GetExceptionInformation())) 
        <BR>{    <BR>ExitProcess(GetExceptionCode()); <BR>} </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">// 
        ПРИМЕЧАНИЕ,    мы никогда не попадем сюда <BR>} </FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">После  инициализации потока система проверяет, был ли передан 
      функции <I>Create Thread  </I>флаг CREATE_SUSPENDED Если нет, система 
      обнуляет его счетчик числа про  стоев, и потоку может быть выделено 
      процессорное время. Далее система загружает  в регистры процессора 
      значения, сохраненные в контексте потока С этого момента  поток может 
      выполнять код и манипулировать данными в адресном пространстве  своего 
      процесса. </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Поскольку  указатель команд нового потока установлен на 
      <I>BaseThreadStart, </I>имен но с  этой функции и начнется выполнение 
      потока. Глядя на ее прототип, можно по  думать, будто <I>BaseThreadStart 
      </I>передаются два параметра, а значит, она  вызывается из какой-то другой 
      функции, но это не так. Новый поток просто  начинает с нее свою работу. 
      <I>BaseThreadStart </I>получает доступ к двум  параметрам, которые 
      появляются у нее потому, что операционная система записывает 
       соответствующие значения в стек по тока (а через него параметры как раз и 
       передаются функциям), Правда, на некоторых аппаратных платформах 
      параметры  передаются не через стек, а с использованием определенных 
      регистров процессора  Поэтому на таких аппаратных платформах система — 
      прежде чем разрешить потоку  выполнение функции <I>BaseThreadStart </I>— 
      инициализирует нужные регистры  процессора. </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Когда новый  поток выполняет <I>BaseThreadStart, </I>происходит 
      следующее. </FONT></P>
      <UL>
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Ваша   функция потока включается во фрейм структурной обработки 
        исключе ний (далее   для краткости — SEH-фрейм), благодаря чему любое 
        исключение, если оно   происходит в момент выполнения Вашего потока, 
        получает хоть ка кую-то   обработку, предлагаемую системой по умолчанию. 
        Подробнее о струк турной   обработке исключений см. главы 23, 24 и 25. 
        </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Система   обращается к Вашей функции потока, передавая ей 
        параметр<I>pvParam</I>,    который Вы ранее передали функции 
        <I>CreateTbread</I> </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Когда Ваша   функция потока возвращает управление, 
        <I>BaseThreadStart </I>вspывает    <I>ExitThread, </I>передавая ей 
        значение, возвращенное Вашей функцией. Счетчик   числа пользователей 
        объекта ядра "поток» уменьшается на 1, и выполнение потока   
        прекращается </FONT></LI></UL>
      <UL>
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Если Ваш   поток вызывает необрабатываемое им исключение, его 
        обрабатыва ет SEH-фрейм,    построенный функцией <I>BaseThreadStart 
        </I>Обычно в результате этого   появляется окно с каким-нибудь 
        сообщением, и, когда пользователь зак рывает   его, <I>BaseThreadStart 
        </I>вызывает <I>ExitProcess </I>и завершает весь   процесс, а не только 
        тот ноток, в котором произошло исключение.  </FONT></LI></UL>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Обратите  внимание, что из <I>BaseThreadStart </I>поток вызывает 
      либо <I>ExitThread,  </I>либо <I>ExitProcess </I>А это означает, что поток 
      никогда не выходит из  данной функции; он все гда уничтожается внутри нее. 
      Вот почему  <I>BaseThreadStart </I>нет<I></I>возвращаемого значе ния — она 
      просто ничего не  возвращает. </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Кстати,  именно благодаря <I>BaseThreadStart </I>Ваша функция 
      потока получает возмож  ность вернуть управление по окончании своей 
      работы. <I>BaseThteadSlart,  </I>вызывая фун кцию потока, заталкивает в 
      стек свой адрес возврята и тсм самым  сообщает ей, куда надо вернуться. Но 
      сама <I>BaseThreadStart </I>не возвращает  управление. Иначе возникло бы 
      нарушение доступа, так как в стеке потока нет ее  адреса возврата. 
      </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">При 
       инициализации первичного потока его указатель команд устанавливается на 
      другую  недокументированную функцию — <I>BaseProcessStart </I>Она почти 
      идентична  <I>BaseThreadStart </I>и выглядит примерно так: </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">VOID 
          BaseProcessStart(PPROCESS_START_BOUTINE pfnStartAddr) <BR>{</FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">__try <BR>{    <BR>ExitThread((pfnStartAdd r)()); <BR>} 
        </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">_except(UnhandledFxceptionFilter(GetExceptionInformation())) 
        <BR>{    <BR>ExitProcess(GettxceptionCode());<BR>} </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">// 
        ПРИМЕЧАНИЕ,    мы никогда не попадем сюда <BR>} </FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Единственное  различие между этими функциями в отсутствии ссылки 
      на параметр <I>pvParam.  </I>Функция <I>BaseProcessStart </I>обращается к 
      стартовому коду библиотеки  С/С++, который выполняет необходимую 
      инициализацию, а затем вызывает Ramy  входную функцию <I>main, wmain, 
      WinMain </I>или <I>wWinMain. </I>Когда входная  функция возвращает 
      управление, стартовый код библиотеки С/С++ вызываст  <I>ExitProcess</I>. 
      Поэтому первич ный поток приложения, написанного на С/С++,  никогда не 
      возвращается в <I>Base ProcessStart.</I> </FONT></P>
      <H2><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="2"><B><A name="h6t7"></A>Некоторые соображения по библиотеке 
      С/С++</B> </FONT></H2>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Microsoft  поставляет с Visual С++ шесть библиотек С/С++. Их 
      краткое описание пред ставлено  в следующей таблице. </FONT></P>
      <TABLE width="545" height="121" align="center" border="1" rules="all" 
      frame="box" cellspacing="0" cellpadding="0">
        <TBODY>
        <TR align="left" valign="top">
          <TD width="120" height="22" align="left" valign="top">
            <P><FONT color="#000000" face="Times New Roman, Times, serif" size="2">Имя 
                  библиотеки </FONT></P></TD>
          <TD width="558" height="22" align="left" valign="top">
            <P><FONT color="#000000" face="Times New Roman, Times, serif" size="2">Описание</FONT></P></TD></TR>
        <TR align="left" valign="top">
          <TD width="120" height="20" align="left" valign="top">
            <P><FONT color="#000000" face="Times New Roman, Times, serif" size="2">LibC.lib 
            </FONT></P></TD>
          <TD width="558" height="20" align="left" valign="top">
            <P><FONT color="#000000" face="Times New Roman, Times, serif" size="2">Статически 
            подключаемая библиотека для </FONT><FONT color="#000000" face="Times New Roman, Times, serif" 
            size="2">однопоточных       приложений </FONT></P></TD></TR>
        <TR align="left" valign="top">
          <TD width="120" height="20" align="left" valign="top">
            <P><FONT color="#000000" face="Times New Roman, Times, serif" size="2">LibCD.lih</FONT></P></TD>
          <TD width="558" height="20" align="left" valign="top">
            <P><FONT color="#000000" face="Times New Roman, Times, serif" size="2">Отладочная 
            версия статически подключаемой библиотеки для однопо        
            </FONT></P></TD></TR>
        <TR align="left" valign="top">
          <TD width="120" height="22" align="left" valign="top">
            <P><FONT color="#000000" face="Times New Roman, Times, serif" size="2">LibCMt.lib 
            </FONT></P></TD>
          <TD width="558" height="22" align="left" valign="top">
            <P><FONT color="#000000" face="Times New Roman, Times, serif" size="2">Статически 
            подключаемая библиотека для </FONT><FONT color="#000000" face="Times New Roman, Times, serif" 
            size="2">многопоточных       приложений </FONT></P></TD></TR>
        <TR align="left" valign="top">
          <TD width="120" height="2" align="left" valign="top">
            <P><FONT color="#000000" face="Times New Roman, Times, serif" size="2">LibCMtD.lib</FONT></P></TD>
          <TD width="558" height="2" align="left" valign="top">
            <P><FONT color="#000000" face="Times New Roman, Times, serif" size="2">Отладочная 
            версия статически подключаемой библиотеки для много        
            </FONT></P></TD></TR>
        <TR align="left" valign="top">
          <TD width="120" height="20" align="left" valign="top">
            <P><FONT color="#000000" face="Times New Roman, Times, serif" size="2">MSVCRt.lib</FONT></P></TD>
          <TD width="558" height="20" align="left" valign="top">
            <P><FONT color="#000000" face="Times New Roman, Times, serif" size="2">Библиотека 
            импорта для динамического подключения рабочей версии        
            </FONT></P></TD></TR>
        <TR align="left" valign="top">
          <TD width="124" height="2" align="left" valign="top">
            <P><FONT color="#000000" face="Times New Roman, Times, serif" size="2">MSVCRtD.lib 
            </FONT></P></TD>
          <TD width="556" height="2" align="left" valign="top">
            <P><FONT color="#000000" face="Times New Roman, Times, serif" size="2">Библиотека 
            импорта дли динамического подключения отладочной версии        
            MSVCRtD.dll; поддерживает как одно-, так и многопоточные приложения  
                  </FONT></P></TD></TR></TBODY></TABLE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">При 
       реализации любого проекта нужно знать, с какой библиотекой его следует 
      связать.  Конкретную библиотеку можно выбрать в диалоговом окне Project 
      Settings: на  вкладке С/С++ в списке Category укажите Code Generation, а в 
      списке Use Run-Time  </FONT><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Library —  одну из шести библиотек. </FONT></P>
      <P align="center"><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3"><IMG width="433" height="279" alt="h5-6.jpg" src="Глава%206_%20Базовые%20сведения%20о%20потоках%20_files/h5-6.jpg"> 
      </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Наверное, Вам  уже хочется спросить: "А зачем мне отдельные 
      библиотеки для од нопоточных и  многопоточных программ?» Отвечаю. 
      Стандартная библиотека С была разработана  где-то в 1970 году — задолго до 
      появления самого понятия многопоточ ности.  Авторы этой библиотеки, само 
      собой, не задумывались о проблемах, связан ных с  многопоточными 
      приложениями. </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Возьмем, к  примеру, глобальную переменную <I>errno </I>из 
      стандартной библиотеки С.  Некоторые функции, если происходит какая-нибудь 
      ошибка, записывают в эту пере  менную соответствующий код. Допустим, у Вас 
      есть такой фрагмент кода:  </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">BOOL 
        fFailure   = (system("NOTEPAD.EXE README.TXT") == -1); </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">if 
        (fFailure)    <BR>{<BR>switch (errno) <BR>{ <BR>case E2BIG:<B></B><BR>// 
        список аргументов   или размер окружения слишком велик <BR>break; 
        </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">case 
        ENOENT:    <BR>// командный интерпретатор не найден <BR>break; 
        </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">case 
          ENOEXEC;<BR>// неверный формат командного интерпретатора <BR>break;  
        </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">case 
          ENOMEM:<BR>// недостаточно памяти для выполнения команды 
        <BR>break;<BR>}    </FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Теперь  представим, что поток, выполняющий показанный выше код, 
      прерван после вызова  функции <I>system </I>и до оператора <I>if. 
      </I>Допустим также, поток прерван  для выпол </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">нения другого  потока (в том же процессе), который обращается к 
      одной из функций библиотеки С,  и та тоже заиосит какое то значение в 
      глобальную переменную <I>errno  </I>Смотрите, что получается когда 
      процессор вернется к выполнению первого  потока, в переменной <I>errno 
      </I>окажется вовсе не то значение, которое было  записано функци ей 
      <I>system</I> Поэтому для решения этой проблемы нужно  закрепить за каждым 
      потоком свою переменную <I>errno </I>Кроме того, понадобится  какой-то 
      механизм, который позво лит каждому потоку ссылаться на свою переменную  
      <I>errno </I>и нс трогать чужую </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">Это 
      лишь один  пример того, что стандартная библиотека С/С++ не рассчитана на 
      многопоточные  приложения Кроме <I>errno, </I>в ней есгь еще целый ряд 
      переменных и функций, с  которыми возможны проблемы в многопоточной среде 
      <I>_doserrno, strtok, _wcstok,  strerror, _strerror, tmpnam, tmpfile, 
      a&lt;tcttme, _wascttme, gmttme, _ecvt,  _Jcvt — </I>спи сок можно 
      продолжить </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Чтобы  многопоточные программы, использующие библиотеку С/С++, 
      работали корректно,  требуется создать специальную структуру данных и 
      связать ее с каждым потоком, из  которого вызываются библиотечные функции 
      Более того, они должны знать, что,  когда Вы к ним обращаетесь, нужно 
      просматривать этот блок данных в вызывающем  потоке чтобы не повредить 
      данные в каком-нибудь другом потоке </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">Так 
      откуда же  система знает, что при создании нового потока надо создать и 
      этот блок  данных<SUP>3</SUP> Ответ очень прост не знает и знать не хочет 
      Вся  ответственность — исключительно на Вас Если Вы пользуетесь 
      небезопасными в  многопоточной среде функциями, то должны создавать потоки 
      библиотечной функцией  <I>_begmthreadex, </I>а не Windows-функцией 
      <I>CreateThread</I> </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">unsigned long  _beginthreadex( void *secunty unsigned stack size 
      unsigned (*start_address)(void  *) void *arglist unsigned initflag 
      unsigned *thrdaddr) </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">У 
      функции  <I>_beginthreadGX </I>тот же список параметров, что и у 
      <I>CreateTbread, </I>но  их имена и типы несколько отличаются (Группа, 
      которая отвечает в Microsoft за  разра ботку и поддержку библиотеки С/С++, 
      считает, что библиотечные функции не  долж ны зависеть от типов данных 
      Wmdows) Как и <I>CreateTbread, </I>функция  <I>_beginthreadex 
      </I>возвращает описатель только что созданного потока Поэтому,  если Вы 
      раньше поль зовались функцией <I>CreateThread, </I>cc вызовы в исходном 
       коде несложно заменить на вызовы <I>_begtnthreadex </I>Однако из-за 
      некоторого  расхождения в типах данных Вам придется позаботиться об их 
      приведении к тем,  которые нужны функции <I>_begin threadex, </I>и тогда 
      компилятор будет счастлив  Лично я создал небольшой макрос 
      <I>chBEGINTHREADEX, </I>который и делает всю эту  работу в исходном 
      коде</FONT><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3"> </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">typedef   unsigned ( stdcall *PTHREAD START) (void *) 
        </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">#define   chBEGINTHREADEX(psa cbStack pfnStartAddr \ 
        <BR>pvParam fdwCreate pdwThreadID)   \ <BR>((HANDLE) _beginthreadex( \ 
        <BR>(void *) (psa) \ <BR>(unsigned)   (cbStack), 
        \<SUP></SUP><BR>(PTHREAD_START) (pfnStartAddr) \ <BR>(void *)   
        (pvParam) \ <BR>(unsigned) (fdwCreate) \ <BR>(unsigned *) 
        (pdwThreadID)))    </FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Заметьте, что  функция <I>_beginthreadex </I>существует только в 
      многопоточных верси ях  библиотеки С/С++. Связав проект с однопоточной 
      библиотекой, Вы получите от  компоновщика сообщение об ошибке "unresolved 
      external symbol». Конечно, это сде  лано специально, потому что 
      однопоточная библиотека не может корректно рабо тать  в мпогопоточном 
      приложении. Также обратите внимание на то, что при созда нии  нового 
      проекта Visual Studio по умолчанию выбирает однопоточную библиоте ку.  
      Этот вариант не самый безопасный, и для многопоточных приложений Вы долж 
      ны сами  выбрать одну из многопоточных версий библиотеки С/С++. 
</FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Поскольку  Microsoft поставляет исходный код библиотеки С/С++, 
      несложно разоб раться в том,  что такого делает <I>_beginthreadex, 
      </I>чего не делает <I>CreateThread, </I>На  дистри бутивном компакт-диске 
      Visual Studio ее исходный код содержится в файле  Threadex.c. Чтобы нс 
      перепечатывать весь код, я решил дать Вам cc версию в  псевдокоде, выде 
      лив самые интересные места. </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">unsigned long   _cdocl _beginthreadex ( void *psa, unsigned 
        cbStack, <BR>unsigned (__stdcall *   pTnStartAddr) (void *), 
        void<B></B>*pvParam, unsigned fdwCreate, unsigned   *pdwThreadID) <BR>{ 
        <BR>_ptiddata ptd; <BR>// указатель на блок данных потока    unsigned 
        long thdl, <BR>// описатель потока <BR>// выделяется блок данных для   
        нового потока </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">if 
        ((ptd =   _calloc_crt(1, sizeof(struct tiddata))) == NULl) <BR>goto   
        error_returnж</FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">//   
         инициализация блока данных <BR>initptd(ptd); </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">// 
        здесь   запоминается нужная функция потока и параметр, <BR>// который мы 
        хотим   поместить в блок данных <BR>ptd-&gt;_initaddr = (void *) 
        pfnStartAddr;    <BR>ptd-&gt;_initarg = pvParam; </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">// 
        создание    Honoio потока </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">thdl 
        =   (unsigned long) <BR>CreateThread(psa, cbStack, _threadstartex, 
        (PVOID) ptd,   fdwCreate, pdwThrcadID); </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">if 
        (thdl ==   NULl) { <BR>// создать поток не удалось, проводится очистка и 
        сообщается об   ошибке <BR>goto error_return; <BR>} </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">// 
        поток   успешно создан; возвращается его описатель <BR>return(thdl); 
        </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">error_return:    <BR>// ошибка! не удалось создать блок данных 
        или сам поток    <BR>_free_crt(ptd); </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">return((unsigned long)0L); </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">}  
        </FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Несколько  важных моментов, связанных с <I>_beginthreadex</I> 
      </FONT></P>
      <UL>
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Каждый   поток получает свой блок памяти <I>tiddata, 
        </I>выделяемый из кучи, кото рая   принадлежит библиотеке С/Г++ 
        (Структура <I>tiddata </I>определена в файле    Mtdll h. Она довольно 
        любопытна, и я привел ее на рис 6-2 ) </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Адрес   функции потока, переданный <I>_beginthreadex, 
        </I>запоминается в блоке па мяти    <I>tiddata </I>Там же сохраняется и 
        параметр, который должен быть передан этой   функции </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Функция    <I>_beginthreadex </I>вызывает <I>CreateThread, 
        </I>так как лишь с ее помощью   операционная система может создать новый 
        поток </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">При вызове    <I>CreateThread </I>сообщается,<I></I>что она 
        должна начагъ выполнение но   вого потока с функции <I>_threadstartex, 
        </I>а не с того адреса, на который   указыва ет <I>fnStartAddr </I>Кроме 
        тою, функции потока передается не параметр    <I>рvParam</I> а адрес 
        структуры <I>tiddata</I> </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Если все   проходит успешно, <I>beginthreadex, </I>как и 
        <I>CreateThread, </I>возвращает   описатель потока В ином случае 
        возвращается NULL </FONT><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3"></FONT>   
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">struct tiddata    <BR>{ <BR>unsigned long _tid; /* 
        идентификатор потока */ <BR>unsigned long   _thandle; /* описатель 
        потока */ <BR>int terrno; /* значение errno   */<BR>unsigned long 
        tdoserrno; /* значение _doserrno */ <BR>unsigned int   _fpds; /* сегмент 
        данных Floating Point */ <BR>unsigned lonq _holdrand; /*    зародышевое 
        значение для rand() */ <BR>char * _token; /* указатель (ptr) на   метку 
        strtok() */ </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">#ifdef _WIN32    <BR>wchar_t *_wtoken; /* ptr на метку wcstok() 
        */ <BR>#endif /* _WIN32 */    </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">unsigned char   * _mtoken; /* ptr на метку _mbstok() */ 
        </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">/* 
        следующие   указатели обрабатываются функцией malloc в период выполнения 
        */ <BR>char *   _errmsg; /* ptr на буфер strerror()/_strerror() 
        */<BR>char * _namebuf0; /* ptr    на буфер tmpnam() */ </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">#ifdef _WIN32    <BR>wchar_t * _wnarnebuf0; /* ptr на 
        буфер_wtmpnam() */ <BR>#endif /* _WIN32   */ </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">char 
        *   _namebuf1 /* ptr на буфер tmpfile() */ </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">#ifdef _WIN32    <BR>wchar_t * _wnamebuf1; /* ptr ма буфер 
        wTmpfi]e() */ <BR>#endif /* _WIN32   */ </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">char 
        *   _asctimebuf; /* ptr на буфер asctime() */ </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">#ifdef _WIN32    <BR>wchar_t * _wasctimebuf; /* ptr на буфер 
        _wasctime() */ <BR>#endif /*   _WIN32 */ </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">void 
        *   _gmtimebuf; /* ptr на структуру gmtime() */ <BR>char * _cvtbuf; * /* 
        ptr на   буфер ecvt()/fcvt */ </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">/* 
        следующие   поля используются кодом _beginthread */ <BR>void * 
        _initaddr; /* начальный   адррс пользовательское потока */ <BR>void * 
        _initarg; /* начальный аргумент   пользовательского потока */ 
</FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">/* 
        следующие   три поля нужны для поддержки функции signal и обработки 
        ошибок, возникающих в   период выполнения */ </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">void 
        *   _pxcptaottab; /* ptr на таблицу исключение-действие */ <BR>void *   
        _tpxcptaofoptrs; /* ptr на указагели к информации об исключении */ 
        <BR>int   _tfpecode; /* код исключения для операций над числами с 
        плавающей точкой */    </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">/* 
        следующее   поле нужно подпрограммам NLG */ <BR>unsigned long 
        _NLG_dwCode;</FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">/* 
        данные для   отдельного потока используемые при обработке исключений в 
        С++ */ </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">void 
        *   _terminate; /* подпрограмма terminate() */ <BR>void * _unexpected; 
        /*    подпрограмма unexpected() */ <BR>void * _translator; /* транслятор 
        S E */    <BR>void * _curexception; /* текущее исключение */ <BR>void * 
        _curcontext; /*    контекст текущего исключения */ </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">#if 
        defined   (_M_MRX000) <BR>void * _pFrameInfoChain; <BR>void * 
        _pUnwindContext; <BR>void   * _pExitContext, <BR>int _MipsPtdDelta; 
        <BR>int _MipsPtdEpsilon;<BR>#elif   defined (_M_PPC)<BR>void * 
        __pExitContext; <BR>void * _pUnwindContext;    <BR>void * 
        _pFrameInfoChain; <BR>int _FrameInfo[6]; <BR>#endif /* defined   
        (_M_PPC) */ </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">}; 
        </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">typedef struct   _tiddata * _ptiddata; </FONT></P></LI></UL>
      <P align="center"><FONT color="#009900" face="Arial, Helvetica, sans-serif" 
      size="2">Рис. 6-2. Локальная структура tiddata потока, определенная в 
      библиотеке  С/С++</FONT><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3"> </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Выяснив, как  создается и инициализируется структура <I>tiddata 
      </I>для нового потока,  посмотрим, как она сопоставляется с этим потоком 
      Взгляните на исходный код фун  кции <I>_threadstartex </I>(который тоже 
      содержится в файле Threadex с  библиотеки С/С++) Вот моя версия этой 
      функции в псевдокоде</FONT><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3"> </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">static   unsigned long WINAPI threadstartex (void* ptd) <BR>{ 
        </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">// 
        Примечание    ptd - это адрес блока tiddata данного потока <BR>// блок 
        tiddata    сопоставляется с данным потоком </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">TlsSetValue(   __tlsindex ptd); </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">//   
         идентификатор этого потока записывается в tiddata <BR>((_ptiddata)   
        ptd)-&gt;_tid = GetCurrentThreadId();<BR>// здесь инициализируется 
        поддержка   операций над числами с плавающей точкой <BR>// (код не 
        показан) </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">//   
         пользовательская функция потока включается в SEH-фрейм для обработки 
        <BR>//    ошибок периода выполнения и поддержки signal <BR>__try <BR>{ 
        </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">// 
        здесь   вызывается функция потока, которой передается нужный параметр; 
        <BR>// код   завершения потока передается _endthreadex <BR>_endthreadex( 
        ( (unsigned   (WINAPI *)(void *))(((_ptiddata)ptd)-&gt;_initaddr) ) (   
        ((_ptiddata)ptd)-&gt;_initarg ) ) ; </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">} 
        </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">_except(_XcptFilter(GetExceptionCode(), 
        GetExceptionInformation()))    <BR>{ <BR>// обработчик исключений из 
        библиотеки С не даст нам попасть сюда    <BR>_exit(GetExceptionGode()); 
        </FONT></P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">} 
        </FONT>   
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">// 
        здесь мы   тоже никогда не будем, так как в этой функции поток умирает 
        </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">return(0L);    <BR>} </FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Несколько  важных моментов, связанных со _<I>threadstartex.</I> 
      </FONT></P>
      <UL>
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Новый   поток начинает выполнение с BaseThreadStart (в 
        Kernel32.dll), а затем   переходит в _threadstartex. </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">В качестве   единственного параметра функции _threadstartex 
        передается адрес блока tiddata    нового потока, </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Windows-функция TlsSetValue сопоставляет с вызывающим потоком 
        значение,    которое называется локальной памятью потока (Thread Local 
        Storage, TLS) (о ней   я расскажу в главе 21), a _threadstartex 
        сопоставляет блок tiddata с новым   потоком. </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Функция   потока заключается в SEH-фрейм. Он предназначен для 
        обработки ошибок периода   выполнения (например, не перехваченных 
        исключений С++), поддержки библиотечной   функции signal и др. Этот 
        момент, кстати, очень ва жен. Если бы Вы создали   поток с помощью 
        CreateThread, а потом вызвали биб лиотечную функцию signal,    она 
        работала бы некорректно. </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Далее   вызывается функция потока, которой передается нужный 
        параметр. Ад рес этой   функции и ее параметр были сохранены в блоке 
        tiddata функцией _beginthreadex.    </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Значение,    возвращаемое функцией потока, считается кодом 
        завершения это го потока.    Обратите внимание: _threadstartex не 
        возвращается в BaseThreadStart. Иначе   после уничтожения потока его 
        блок tiddata так и остался бы в памяти. А это   привело бы к утечке 
        памяти в Вашем приложении. Чтобы избежать этого,    threadstartex 
        вызывает другую библиотечную функцию, _endthreadex, и пере дает   ей код 
        завершения. </FONT></LI></UL>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Последняя  функция, которую нам нужно рассмотреть, — это 
      <I>_endthreadex </I>(ее ис ходный  код тоже содержится в файле 
      Threadex.c). Вот как она выглядит в моей вер сии (в  псевдокоде) 
      </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">void 
        _cdecl   _endthreadex (unsigned retcode) <BR>{<I></I><BR>_ptiddata ptd; 
        <BR>//    указатель на блок данных потока </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">// 
        здесь   проводится очистка ресурсов, выделенных для поддержки операций 
        <BR>// над   числами с плавающей точкой (код не показан) 
      </FONT></P></BLOCKQUOTE>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">// 
        определение   адреса блока tiddata данного потока <BR>ptd = 
        _getptd();</FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">//   
         высвобождение блока tiddata<I></I><BR>_freeptd(ptd);</FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">// 
        завершение   потока <BR>ExitThread(retcode); <BR>} 
</FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Несколько  важных моментов, связанных <I>с _endthreadex</I> 
      </FONT></P>
      <UL>
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Библиотечная функция _<I>getptd </I>обращается к 
        Windows-функции    <I>TlsGetValue, </I>которая сообщает адрес блока 
        памяти <I>tiddata    </I>вызывающего потока </FONT>   
        <LI><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3">Этот блок   освобождается, и вызовом <I>ExttThread </I>поток 
        разрушается. При этом,    конечно, передается корректный код завершения. 
        </FONT></LI></UL>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Где-то в  начале главы я уже говорил, что прямого обращения к 
      функции <I>ExitThread  </I>следует иpбегать Это правда, и я не отказываюсь 
      от своих слов. Тогда же я  сказал, что это приводит к уничтожению 
      вызывающего потока и не позволяет ему  вернуться из выполняемой в данный 
      момент функции А поскольку она не возвращает  управление, любые созданные 
      Вами С++-объекты не разрушаются. Так вот, теперь у  Вас есть еще одна 
      причина не вызывать <I>ExitThread. </I>она не дает освободить  блок памяти 
      <I>tiddata </I>потока, из-за чего в Вашем приложении может  наблюдаться 
      утечка памяти (до его pавершения) </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Разработчики  Microsoft Visual C++, конечно, прекрасно понимают, 
      что многие все равно будут  пользоваться функцией <I>ExitThread, 
      </I>поэтому они кое-что сделали, чтобы  свести к минимуму вероятность 
      утечки памяти. Если Вы действительно так хотите  самостоятельно уничтожить 
      свой поток, можете вызвать из него <I>_endthreadex  </I>(вмес то 
      <I>ExitTbread) </I>и тем самым освободить его блок <I>tiddata.  </I>И все 
      же я не рекомендую этого </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Сейчас Вы уже  должны понимать, зачем библиотечным функциям нужен 
      отдель ный блок данных для  каждого порождаемого потока и каким образом 
      после вызова <I>_beginthreadex  </I>происходит создание и инициализация 
      этого блока данных, а также его  связывание с только что созданным 
      потоком. Кроме того, Вы уже должны разби  раться в том, как функция 
      <I>_endthreadex </I>освобождает этот блок по  завершении потока. 
      </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">Как 
      только  блок данных инициализирован и сопоставлен с конкретным потоком, 
      любая  библиотечная функция, к которой обращается поток, может легко 
      узнать ад рес его  блока и таким образом получить доступ к данным, 
      принадлежащим этому потоку.  </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Ладно, с  функциями все ясно, теперь попробуем проследить, что 
      происходит с глобальными  переменными вроде <I>errno. </I>В заголовочных 
      файлах С эта переменная  определена так: </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">#if  
         defined(_MT) || defined(_DLL) <BR>extern<B></B>int * _cdecl   
        _errno(void);<BR>#define errno (*_еггпо()) <BR>#else /* ndef _MT 
        &amp;&amp;   ndef _DLL */ <BR>extern int errno; <BR>#endif /* MT | | 
        _DLL */  </FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Создавая  многопоточное приложение, надо указывать в командной 
      строке ком пилятора один из  ключей /MT (многопоточное приложение) или /MD 
      (многопоточ </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">ная 
      DLL);<B></B>тогда компилятор определит идентификатор _MT. После этого, 
      ссылаясь на  <I>errno, </I>Вы будете на самом деле вызывать внутреннюю 
      функцию <I>_errno  </I>из библиотеки С/С++. Она возвращает адрес элемента 
      данных <I>errno </I>в  блоке, сопоставленном с вы зывающим потоком. 
      Кстати, макрос <I>errno  </I>составлен так, что позволяет получать co 
      держимое памяти по этому адресу А  сделано это для того, чтобы можно было 
      писать, </FONT><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">например, такой код  </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">int 
        *p =   &amp;errno; </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">if 
        (*p ==   ENOMEM){<BR>...<BR>} </FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Если бы  внутренняя функция <I>_errno </I>просто возвращала 
      значение <I>errno, </I>этот  код не удалось бы скомпилировать. </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Многопоточная  версия библиотеки С/С++, кроме того, "обертывает" 
      некоторые функции  синхронизирующими примитивами Всдь если бы два потока 
      одновремен но вызывали  функцию <I>malloc, </I>куча могла бы быть 
      повреждена. Поэтому в многопо точной  версии библиотеки потоки не могут 
      одновременно выделять память из кучи. Второй  поток она заставляет ждать 
      до тех пор, пока первый не выйдет из функции  <I>malloc, </I>и лишь тогда 
      второй поток получает доступ к <I>malloc.  </I>(Подробнее о синхрони зации 
      потоков мы поговорим в главах 8, 9 и 10.)  </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Конечно, все  эти дополнительные операции нс могли не отразиться 
      на быстро действии  многопоточной версии библиотеки Поэтому Microsoft, 
      кроме многопоточ ной,  поставляет и однопоточную версию статически 
      подключаемой библиотеки С/С++.  </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Динамически  подключаемая версия библиотеки С/С++ вполне 
      универсальна ее могут использовать  любые выполняемые приложения и DLL, 
      которые обращаются к библиотечным функциям.  По этоЙ причине данная 
      библиотека существует лишь в многопоточной версии.  Поскольку она 
      поставляется в виде DLL, ее код не нужно вклю чать непосредственно  в EXE- 
      и DLL-модули, что существенно уменьшает их размер. Кроме того, если  
      Microsoft исправляет какую-то ошибку в такой библиотеке, то и программы,  
      построенные на ее основе, автоматически избавляются от этой ошибки 
      </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">Как 
      Вы,  наверное, и предполагали, стартовый код из библиотеки С/С++ создает и 
       инициализирует блок данных для первичного потока приложения. Это 
      позволяет без  всяких опасений вызывать из первичного потока любые 
      библиотечные функции А когда  первичный поток заканчивает выполнение своей 
      входной функции, блок дан ных  завершаемого потока освобождается самой 
      библиотекой Более того, стартовый код  делает все необходимое для 
      сгруктурной обработки исключений, благодаря чему из  первичного потока 
      можно спокойно обращаться и к библиотечной функции  <I>signal.</I> 
      </FONT></P>
      <H2><I><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="2"><A name="h6t7p1"></A>Ой, вместо _beginthreadex я по ошибке вызвал 
      CreateThread  </FONT></I></H2>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Вас,  наверное, интересует, что случится, если создать поток не 
      библиотечной функ цией  <I>_begintbreadex, </I>а Windows-функцией 
      <I>CreateThread </I>Когда этот поток  вызовет какую-нибудь библиотечную 
      функцию, которая манипулирует со структурой  <I>tiddata, </I>произойдет 
      следующее. (Большинство библиотечных функций  реентерабсльно и не требует 
      этой структуры ) Сначала эта функция попытается  выяснить адрес блока дан 
      ных потока (вызовом <I>TleGetValue). </I>Получив NULL  вместо адреса 
      <I>tiddata, </I>она узнает, что вызывающий поток не сопоставлен с 
       таким<B></B>блоком. Тогда библиотечная функция тут </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">же 
      создаст и  инициализирует блок <I>tiddata </I>для вызывающего потока. 
      Далее этот блок будет  сопоставлен с потоком (через <I>TlsSetValue) </I>и 
      останется при нем до тех пор,  пока выполнение потока нс прекратится, С 
      этого моменга данная функция (как,  впрочем, и любая другая из библиотеки 
      С/С++) сможет пользоваться блоком  <I>tiddata </I>потока. </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">Как 
      это ни  фантасгично, но Ваш поток будет работать почти без глюков. Хотя 
      некоторые  проблемы все же появятся. Во-первых, если этот поток 
      воспользуется биб лиотечной  функцией <I>signal, </I>весь процесс 
      завершится, так как SEH-фрейм не подго  товлен. Во-вторых, если поток 
      завершится, не вызвав <I>endtbreadex, </I>его  блокданных не высвободится 
      и произойдет утечка памяти. (Да и кто, интересно,  вызовет <I>end threadex 
      </I>иэ потока, созданного с помощью  <I>CreateTbread?</I>)</FONT><FONT 
      color="#000000" face="Times New Roman, Times, serif" size="3"> </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#006600" face="Arial, Helvetica, sans-serif" 
        size="2"><FONT color="#990000">NOTE:</FONT> <BR>Если Вы связываете свой 
        модуль с многопоточной    DLL версией библиотеки С/С++, то при 
        завершении потока и высвобождении блока    <I>tiddata </I>(если он был 
        создан), библиотека получает уведомление    DLL_THREAD_DETACH. Даже не 
        смотря на то что это предотвращает утечку памяти,    связанную с блоком 
        <I>tiddata, я </I>настоятельно советую создавать потоки   через 
        _<I>beginthreadex, </I>а не с помощью <I>CreateTbread.</I>   
        </FONT></P><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3"></FONT></BLOCKQUOTE>
      <H2><I><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="2"><A name="h6t7p2"></A>Библиотечные функции, которые лучше не 
      вызывать </FONT></I></H2>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">В 
      библиотеке  С/С++ содержится две функции: </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">unsigned long   _beginthread( void (__cdecl 
        *stait_address)(void *), unsigned stack_size, void   *arglist); 
        </FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">и 
      </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">void 
          _endthread(void); </FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Первоначально  они были созданы для того, чем теперь занимаются 
      новые функ ции  _<I>beginthreadex </I>и <I>_endthreadex. </I>Нo, как 
      видите, у <I>_begintbread  </I>параметров меньше, и, следовательно, ее 
      возможности ограничены в сравнении с  полнофункциональной 
      <I>beginthreadex. </I>Например, работая с <I>_beginthread,  </I>нельзя 
      создать поток с атрибутами защиты, отличными от присваиваемых по 
       умолчанию, нельзя создать поток и тут же его задержать — нельзя даже 
      получить  идентификатор потока. С функцией _<I>endthread </I>та же 
      история; она не  принимает никаких параметров, а это значит, что по оконча 
      нии работы потока его  код завершения всегда равен 0. </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Однако с  функцией <I>_endthread </I>дело обстоит куда хуже, чем 
      кажется: перед вызо вом  <I>ExitThread </I>она обращается к <I>CloseHandle 
      </I>и передает ей описатель  нового потока. Чтобы разобраться, в чем тут 
      проблема, взгляните на следующий  код: </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">DWORD   dwExitCode; </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">HANDLE   hThreatf = _beglntnread(...); </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">GetExitCodeThread(hThread &amp;dwExitCode); </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">CloseHandle(hThread); </FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Весьма  вероятно, что созданный поток отработает и завершится еще 
      до того, как первый  поток успеет вызвать функцию <I>GetExitCodeThread. 
      </I>Если так и случится,  значе ние в <I>hThread </I>окажется 
      недействительным, потому что <I>_endtbread  </I>уже<I></I>закрыла опи 
      сатель нового потока. И, естественно, вызов  <I>CloseHandle </I>дает 
      ошибку. </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Новая функция  _<I>endthreadex, </I>не закрывает описатель 
      потока, поэтому фрагмент кода,  приведенный выше, будет нормально работать 
      (если мы, конечно, заменим вы зов  <I>_beginthread </I>на вызов 
      <I>_beginthreadex</I>)<I></I>И в заключение,  напомню еще раз: как толь ко 
      функция потока возвращает управление,  <I>_beginthreadex 
      </I>самостоятельно вызывает <I>_endthreadex, </I>a  
      <I>begtnthread</I>обращается к<I>_endthread.</I> </FONT></P>
      <H2><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="2"><B><A name="h6t8"></A>Как узнать о себе</B> </FONT></H2>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Потоки часто  обращаются к Windows-функциям, которые меняют срсду 
      выполнения. Например, потоку  может понадобиться изменить свой приоритет 
      или приоритет процесса. (Приоритеты  рассматриваются в главе 7.) И 
      поскольку это не редкость, когда поток  модифицирует среду (собственную 
      или процесса), в Windows предусмот рены функции,  позволяющие легко 
      ссылаться на объекты ядра текущего процесса и </FONT><FONT color="#000000" 
      face="Times New Roman, Times, serif" size="3">потока: </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">HANDLE   GetCurrentProcess();<BR>HANDLE 
        GetCurrentThread();</FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">Обе 
      эти  функции возвращают псевдоописатсль объекта ядра "процесс" или "по 
      ток" Они не  создают новые описатели в таблице описателей, которая 
      принадлежит вызывающему  процессу, и не влияют на счетчики числа 
      пользователей объектов ядра "процесс» и  "поток" Поэтому, если вызвать 
      <I>CloseHandle </I>и передать ей псевдоописа тель,  она проигнорирует 
      вызов и просто вернет FALSE </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Псевдоописатели можно использовать при вызове функций, которым 
      нужен<B></B>опи сатель процесса Так, поток может запросить все временные 
      показатели  своего про цесса, вызвав <I>GetProcessTimes:</I> </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">FILETIME   ftCreationTime, ftExitTime, ftKernelTime, 
        ftUserTime;    <BR>GetProcessTimes(GetCurrentProcess(), 
        &amp;ftCreationTime, &amp;ftExirTime,   &amp;ftKernelTime, 
        &amp;ftUserTime); </FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Аналогичным  образом поток может выяснить собственные временные 
      показате ли, вызвав  <I>GetThreadTimes:</I> </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">FILETIME   ftCreationTime, ftExitTime, ftKernelTime,   
        ftUserTime;<BR>GetThreadTimes(GetCurrentThread(), &amp;ftCreationTime,   
        &amp;ftExitTime, &amp;ftKernelTime, &amp;ftUserTime); 
      </FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Некоторые  Windows-функции позволяют указывать конкретный процесс 
      или по ток no его  уникальному в рамках всей системы идентификатору. Вот 
      функции, с по мощью  которых поток может выяснить такой идентификатор — 
      собственный или своего  процесса: </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">DWORD   GetCurrentProcessId();<BR>DWORD 
        GelCurrentThreadId();</FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">По 
      сравнению  с функциями, которые возвращают псевдоописатели, эти функции, 
      как правило, не  столь полезны, но когда-то и они могут пригодиться. 
      </FONT></P>
      <H2><I><FONT color="#0000ff" face="Arial, Helvetica, sans-serif" 
      size="2"><A name="h6t8p1"></A>Преобразование псевдоописателя в настоящий 
      описатель  </FONT></I></H2>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Иногда бывает  нужно выяснить настоящий, а не псевдоописатель 
      потока. Под "насто ящим" я  подразумеваю описатель, который однозначно 
      идентифицирует уникальный поток  Вдумайтесь в такой фрагмент кода: 
      </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">DWORD WINAPI   ParentThread(PVOID pvParam) <BR>{ <BR>HANDLE 
        hThreadParent =   GetCurrentThread(); <BR>CreateThread(NULL, 0, 
        ChildThread, (PVOID)   hThreadParent, 0, MULL); </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">// 
        далее   следует какой-то код <BR>} </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">DWORD WINAPI   ChildThread(PVOID pvParam) <BR>{ <BR>HANDLE 
        hThreadParent = (HANDLE)   pvParam;</FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">FILETIME   ftCreationTime, ftExitTime, ftKernelTime, 
        ftUserTime;</FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">GetTh   readTimes(hThreadParent, &amp;ftCreationTime, 
        &amp;ftExitTime,   &amp;ftKernelTime, &amp;ftUserTime); </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">// 
        далее   следует какой-ro код. <BR>} </FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" size="3">Вы 
      заметили,  чго здесь не все ладно. Идея была в том, чтобы родительский 
      поток передавал  дочернему свой описатель. Но он передает псевдо-, а не 
      настоящий описа тель  Начиная выполнение, дочерний поток передает этот 
      псевдоописатель функции  <I>GetThreadTimes, </I>и она вследствие этого 
      возвращает временные показатели  своего — а вовсе не родительского потока. 
      Происходит так потому, что  псевдоописатель яв ляется описателем текущего 
      потока, т e. того, который  вызывает эту функцию. </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Чтобы  исправить приведенный выше фрагмент кода, превратим 
      псевдоописатель в настоящий  через функцию <I>DuplicateHandle </I>(о ней я 
      рассказывал в главе 3):  </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">BOOL  DuplicateHandle( HANDLE hSourceProcess, HANDLE hSource, 
      HANDLE hTargetProcess,  PHANDLE phTarget, DWORD fdwAccess, BOOL 
      bInhentHandle, DWORD fdwOpfions),  </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Обычно она  используется для создания нового 
      "процессо-зависимого» описателя из описателя  объекта ядра, значепие 
      которого увязано с другим процессом. А мы вос пользуемся  
      <I>DuplicateHandle </I>не совсем по назначению и скорректируем с ее 
      помощью наш  фрагмент кода так </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">DWORD WINAPI   ParentThread(PVOID pvParam) <BR>{<BR>HANDLE 
        hThreadParent; </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">DuplicateHandle( <BR>GetCurrentProcebs(), // описатель 
        процесса, к   которому относится псевдоописатель потока, 
        <BR>GetCurrentThread(), //    псевдоописатель родительского потока; 
        <BR>GetCurrentProcess(), // описатель   процесса, к которому относится 
        новый, настоящий описатель потока<SUB></SUB><BR>&amp;hThreadParent, // 
        даст новый настоящий описатель   идентифицирующий родительский поток; 
        <BR>0, // игнорируется из-за    DUPLICATE_SAME_ACCESS<I></I>FALSE, новый 
        описатель потока ненаследуемый,    DUPLICATE_SAME_ACCESS); // новому 
        описателю потока присваиваются те же   атрибуты защиты, что и 
        псевдоописателю</FONT><FONT color="#000000" face="Times New Roman, Times, serif" 
        size="3"> </FONT></P></BLOCKQUOTE>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">CreateThread(NULL, 0, ChildThread, (PVOID) hThreadParent, 0, 
        NULL)   ;</FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">// 
        далее   следует какой-то код <BR>} </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">DWORD WINAPI   ChildThread(PVOID pvParam) <BR>{ </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">HANDLE   hThreadParent = (HANDLE) pvParam;</FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">FILETIME   ftCreaUonTime, ftExitTime, ftKernelTime, 
        ftUserTime;</FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">GetThreadTimes(hThreadParent, &amp;ftCreationTime, 
        &amp;ftExitTime,   &amp;ftKernelTime, &amp;ftUserTime);</FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">CloseHandle(hThreadParent);</FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">// 
        далее   следует какой-то код.. <BR>} </FONT></P></BLOCKQUOTE>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Тeпeрь  родительский поток преобразует свой "двусмысленный» 
      псевдоописатель в настоящий  описатель, однозначно определяющий 
      родительский поток, и передает его в  <I>CreateThread </I>Когда дочерний 
      поток начинает выполнение, его параметр  <I>pvParam</I> содержит настоящий 
      описатель потока. В итоге вызов какой-либо  функции с этим описателем 
      влияет не на дочерний, а на родительский поток  </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Поскольку  <I>DuplicateHandle</I> увеличивает счетчик 
      пользователей указанного объек та  ядра, то, закончив работу с 
      продублированным описателем объекта, очень важно не  забыть уменьшить 
      счетчик Сразу после обращения к <I>GetThreadTimes </I>дочерний  поток 
      вызывает <I>CloseHandle, </I>уменьшая тем самым счетчик пользователей 
       объекта "ро дительский поток" на 1 В этом фрагменте кода я исходил из 
      того, что  дочерний по ток не вызывает других функций с передачей этого 
      описателя Если же  ему надо выз вать какие-то функции с передачей 
      описателя родительского потока,  то, естествен но, к <I>CloseHandle 
      </I>следует обращаться только после тоoro,  как необходимость в этом 
      описателе у дочернего потока отпадет </FONT></P>
      <P><FONT color="#000000" face="Times New Roman, Times, serif" 
      size="3">Надо  заметить, что <I>DuphcateHandle </I>позволяет преобразовать 
      и псевдоописатель  процесса. Вот как это сделать </FONT></P>
      <BLOCKQUOTE>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">HANDLE   hProcess; </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" 
        size="2">DuplicateHandle( <BR>GetCurrentProcess(), // описатель 
        процесса, к   которому относится псевдоописатель, 
        <BR>GetCurrentProcess(), //    псевдоописатель процесса 
        <BR>GetCurrentProcess(), // описатель процесса, к   которому относится 
        новый, настоящий описатель; <BR>&amp;hProcess, // дает   новый, 
        настоящий описатель идентифицирующий процесс, <BR>0, // игнорируется   
        из-за DUPLICATE_SAME_ACCESS, <BR>FALSE, // новый описатель процесса   
        ненаследуемый, <BR>DUPLICATE_SAME_ACCESS); // новому описателю процесса  
         присваиваются </FONT></P>
        <P><FONT color="#0000cc" face="Courier New, Courier, mono" size="2">// 
        те же   атрибуты защиты, что и псевдоописателю </FONT></P></BLOCKQUOTE>
      <HR>
</BODY></HTML>
